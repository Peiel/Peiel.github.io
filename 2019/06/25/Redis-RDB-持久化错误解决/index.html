<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Redis RDB 持久化错误解决"><meta name="keywords" content="Redis,缓存,RDB"><meta name="author" content="Peiel"><meta name="copyright" content="Peiel"><title>Redis RDB 持久化错误解决 | Peiel's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?c04902d5ce57c49a176ac5dae1c54084";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#问题描述"><span class="toc-number">1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#问题分析"><span class="toc-number">2.</span> <span class="toc-text">问题分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#解决方法"><span class="toc-number">3.</span> <span class="toc-text">解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-修改Reids参数-stop-writes-on-bgsave-error-false"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. 修改Reids参数 stop-writes-on-bgsave-error false</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-修改内核参数，在-etc-sysctl-conf-添加-vm-overcommit-memory-1，使用sysctl-p刷新生效。"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 修改内核参数，在 /etc/sysctl.conf 添加 vm.overcommit_memory=1，使用sysctl -p刷新生效。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#首先，这个参数涉及到了在什么情况下，Linux会内存不足？"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">首先，这个参数涉及到了在什么情况下，Linux会内存不足？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其次，当满足内存不足时，操作系统根据overcommit-memory参数来执行不同的策略。"><span class="toc-number">3.0.2.2.</span> <span class="toc-text">其次，当满足内存不足时，操作系统根据overcommit_memory参数来执行不同的策略。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最后，对-Redis-产生了什么影响"><span class="toc-number">3.0.2.3.</span> <span class="toc-text">最后，对 Redis 产生了什么影响</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#思考"><span class="toc-number">4.</span> <span class="toc-text">思考</span></a></li></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Peiel</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/peiel">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">83</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">55</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">22</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/home.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Peiel's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Redis RDB 持久化错误解决</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Redis/">Redis</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Java process log output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. </span><br><span class="line">Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.; nested exception is redis.clients.jedis.exceptions.JedisDataException: MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Redis log output：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5459:M 25 Jun 11:05:55.025 * 1 changes in 900 seconds. Saving...</span><br><span class="line">5459:M 25 Jun 11:05:55.025 # Can&apos;t save in background: fork: Cannot allocate memory</span><br></pre></td></tr></table></figure>
<p>The monitoring system:</p>
<p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/df_free.jpg" alt="df_free.jpg"><br><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/mem_free.jpg" alt="mem_free.jpg"></p>
<p>红色线为 Redis Server 端，蓝色线为连接 Redis 的客户端。可以看到，客户端硬盘和内存的压力都很大，服务端内存也只剩余大约 30% 。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>在 Java 客户端输出的日志上，报错的意思是无法在磁盘进行RDB快照持久化，但是在监控系统中 Redis 所在服务器磁盘并没有压力，可以排除磁盘满而无法进行持久化。</p>
<p>根据 Redis 的报错 <code>Can&#39;t save in background: fork: Cannot allocate memory</code>信息，查看 Redis 相关文档，此报错原因试因为 <code>stop-writes-on-bgsave-error yes</code> 参数而产生的报错，在RDB持久化的进程执行持久化时，Redis 不允许用户进行任何更新操作，与 Java 中的错误日志吻合。</p>
<h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h3 id="1-修改Reids参数-stop-writes-on-bgsave-error-false"><a href="#1-修改Reids参数-stop-writes-on-bgsave-error-false" class="headerlink" title="1. 修改Reids参数 stop-writes-on-bgsave-error false"></a>1. 修改Reids参数 <code>stop-writes-on-bgsave-error false</code></h3><p>在 RDB持久化 出错时，允许用户继续操作。这种方式并没有解决真正的报错，我们来看第二种方式。</p>
<h3 id="2-修改内核参数，在-etc-sysctl-conf-添加-vm-overcommit-memory-1，使用sysctl-p刷新生效。"><a href="#2-修改内核参数，在-etc-sysctl-conf-添加-vm-overcommit-memory-1，使用sysctl-p刷新生效。" class="headerlink" title="2. 修改内核参数，在 /etc/sysctl.conf 添加 vm.overcommit_memory=1，使用sysctl -p刷新生效。"></a>2. 修改内核参数，在 <code>/etc/sysctl.conf</code> 添加 <code>vm.overcommit_memory=1</code>，使用<code>sysctl -p</code>刷新生效。</h3><p>如图，修改后，Redis自动恢复。<br><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/log.jpg" alt="log.jpg"></p>
<p>下面我们来分析一下这个参数</p>
<h4 id="首先，这个参数涉及到了在什么情况下，Linux会内存不足？"><a href="#首先，这个参数涉及到了在什么情况下，Linux会内存不足？" class="headerlink" title="首先，这个参数涉及到了在什么情况下，Linux会内存不足？"></a>首先，这个参数涉及到了在什么情况下，Linux会内存不足？</h4><p>Linux 下 CommitLimit 的大小用来限制用户态可使用的内存资源，通过命令<code>grep -i commit /proc/meminfo</code>，<code>CommitLimit</code>表示内存分配上限，<code>Committed-AS</code>表示已经分配的内存大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommitLimit = 物理内存 * overcommit_ratio(/proc/sys/vm/overcommit_ratio) + swap</span><br></pre></td></tr></table></figure>
<p>当满足下方公式时，系统就会认为内存不足。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序申请内存 + 系统已经分配的内存(Committed-AS) &gt; CommitLimit</span><br></pre></td></tr></table></figure>
<h4 id="其次，当满足内存不足时，操作系统根据overcommit-memory参数来执行不同的策略。"><a href="#其次，当满足内存不足时，操作系统根据overcommit-memory参数来执行不同的策略。" class="headerlink" title="其次，当满足内存不足时，操作系统根据overcommit_memory参数来执行不同的策略。"></a>其次，当满足内存不足时，操作系统根据<code>overcommit_memory</code>参数来执行不同的策略。</h4><ul>
<li>vm.overcommit_memory = 0 启发策略</li>
</ul>
<p>比较 <code>请求分配的内存 &gt; 系统空闲内存 + swap</code> 如果满足，则虚拟地址空间分配失败。 </p>
<ul>
<li>vm.overcommit_memory = 1 允许 overcommit</li>
</ul>
<p>直接放行，不进行任何校验，任何情况下系统都会为应用程序分配虚拟内存空间。<br><strong>弊端</strong>：完全屏蔽了应用程序对系统物理内存的感知，当发生缺页中断的机制来进行分配内存，一旦内存分配失败，会引起系统OOM机制杀进程。</p>
<ul>
<li>vm.overcommit_memory = 2 禁止 overcommit</li>
</ul>
<p>这种情况下系统所能分配的内存不会超过上面提到的 <code>CommitLimit</code> 大小，如果资源用光，任何尝试分配内存的行为都会失败，也就是说不能运行任何新的进程。</p>
<h4 id="最后，对-Redis-产生了什么影响"><a href="#最后，对-Redis-产生了什么影响" class="headerlink" title="最后，对 Redis 产生了什么影响"></a>最后，对 Redis 产生了什么影响</h4><p>Redis 异步 BGSAVE 命令，主进程 fork 后，复制自身并通过这个新的进程来持久化到磁盘，完毕后进程自动关闭。</p>
<p>如果Redis分配的内存太大，在 fork 进程的时候，容易发生内存不足无法fork的情况。</p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>我们平时在使用Rdis的时候，一定要记得给缓存设置有效时间，避免非热点数据占用内存。</li>
<li>Redis的RDB快照持久化需要fork新的进程，在内存占用大时，fork的代价极大。</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Peiel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.peiel.com/2019/06/25/Redis-RDB-持久化错误解决/">http://blog.peiel.com/2019/06/25/Redis-RDB-持久化错误解决/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.peiel.com">Peiel's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/缓存/">缓存</a><a class="post-meta__tags" href="/tags/RDB/">RDB</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/10/31/IDEA-CodeGlance不显示无效不起作用的解决方案/"><i class="fa fa-chevron-left">  </i><span>IDEA CodeGlance插件不显示无效不起作用的解决方案</span></a></div><div class="next-post pull-right"><a href="/2019/04/12/递归的理解/"><span>递归的理解</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="lv-container" data-id="city" data-uid="MTAyMC80NzMyOC8yMzgyOA=="><script>(function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
})(document, 'script');</script></div></div></div><footer class="footer-bg" style="background-image: url(http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/home.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Peiel</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="blog.peiel.com">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>