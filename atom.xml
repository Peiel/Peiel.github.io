<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Peiel&#39;s Blog</title>
  
  <subtitle>大其愿 坚其志 虚其心 柔其气</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.peiel.com/"/>
  <updated>2019-12-24T15:06:48.007Z</updated>
  <id>http://blog.peiel.com/</id>
  
  <author>
    <name>Peiel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stanford University CS144 1.1 总结</title>
    <link href="http://blog.peiel.com/2019/12/24/Stanford-University-CS144-%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.peiel.com/2019/12/24/Stanford-University-CS144-总结/</id>
    <published>2019-12-24T13:19:28.000Z</published>
    <updated>2019-12-24T15:06:48.007Z</updated>
    
    <content type="html"><![CDATA[<p>课程链接：<a href="https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/course/" target="_blank" rel="noopener">点击进入</a></p><p>本节主要介绍的是生活中网络的应用。</p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>基础的通讯模型，服务器A和服务器B相互之间的通讯不公用一条通道，分别用两条通道来进行单边通讯。进一步升级后，两个服务器可以共用同一条通道来进行字节流的读写，其中一方断开连接后，另一方也会收到<code>connection reset by pee</code>断开链接的消息，然后讲了几个应用场景。</p><a id="more"></a><h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><p>万维网中应用最广泛的是<code>HTTP</code>协议，客户端向服务端建立链接后，向服务端发送<code>GET</code>、<code>POST</code> 等命令，服务端收到请求后，对请求进行处理，并返回给客户端响应。</p><h2 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h2><p>BitTorrent 是一个允许用户进行分享和交换大文本的程序，多个 <code>Clint</code> 向 <code>Tracker</code> 来请求获取<code>Clint</code>列表，这些列表统称为 <code>Swarm</code>， 然后通过<code>Clint</code>列表来和各个客户端建立连接，获取自己没有的 <code>piece</code>，通过请求 <code>pieces</code> 来进行数据下载，下载成功后，这个客户端会告诉其他的客户端自己已经拥有这个 <code>piece</code> 了。他的机制和万维网是一样的可靠双全工数据流，但是它的实现要稍微复杂一些。Clint和Tracker之间通过HTTP来进行通讯，Tracker维护着torrent文件记录着你想要下载的数据文件的一些描述信息。客户端和服务端存在着多个链接，而且各个客户端之间也会存在链接来动态的交换数据。</p><h2 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h2><p>Skype 是国外的一款通讯软件，类似与国内微信，这里应该讲的是它开源的相关网络协议的知识，主要的知识点是NAT网关后方的节点可以主动链接没有NAT网关节点，而其他节点无法直接链接到NAT网关后方的节点，这里引入了两个<code>Rendezvous Servers</code> 和 <code>Relays Servers</code>，<code>Rendezvous Servers</code> 帮组两端来建立链接，<code>Relays Servers</code> 来进行数据的中转。</p><h2 id="课后习题解题思路"><a href="#课后习题解题思路" class="headerlink" title="课后习题解题思路"></a>课后习题解题思路</h2><p>记录下 <code>1-1A</code> 的解题思路，<code>1-1B</code> 和 <code>1-1C</code> 比较简单，不记录了。</p><h3 id="读题："><a href="#读题：" class="headerlink" title="读题："></a>读题：</h3><p>有一家游戏公司，要给用户分发更新包，然后说明了一些参数：</p><ul><li>更新包大小约1GB</li><li>更新服务器的带宽约1GB/s</li><li>假设每个用户的下载速度为 1M/s</li><li>有100,000个玩家</li></ul><p>提供了两种方案：</p><p>第一种：使用普通的网络协议下载，用户按顺序一轮一轮的下载，通过计算需要100轮，每轮1000个用户下载完成，大约需要耗时100,000秒（~28H）。</p><p>第二种：使用 <code>peer-to-peer</code>（称点对点、对等网络）来进行分发下载，第一轮1000个用户下载，第二轮1000个用户通过服务器下载，1000个用户通过其他用户来下载，第三轮1000个用户通过服务器下载，2000个用户通过其他用户来下载，以此类推。。。</p><p>问：知道最后一个用户更新完毕第二种方式耗时多少？第一个方式比第二种方式快多少倍？</p><h3 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h3><p>已知第一种方式耗时100,000秒。然后计算第二种方式的耗时：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">单轮下载用户： 1000100010001000100010001000</span><br><span class="line">1000300070001500031000630000</span><br><span class="line"></span><br><span class="line">累计下载量：  1000    30007000150003100063000127000</span><br></pre></td></tr></table></figure></p><p>看到需要7轮全部用户即可更新完毕，耗时 <code>7 * 1000 = 7000</code>秒。<br>第二种比第一种快了约 <code>100000 / 7000 ≈ 14</code>倍。</p><h2 id="思考总结"><a href="#思考总结" class="headerlink" title="思考总结"></a>思考总结</h2><p>这节总得来说讲的都是一些介绍性知识，没有很大的难度也没有深入的一些讲解，相对来说通俗易懂。主要的疑问点如下：</p><ul><li>NAT网关后方的节点为何其他节点不能直接建立链接？现在大多数设备接入互联网都需要经过NAT网关吧，后续的学习可以注意思考通这个问题。</li></ul><hr><blockquote><p>待加入配图</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;课程链接：&lt;a href=&quot;https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/course/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击进入&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本节主要介绍的是生活中网络的应用。&lt;/p&gt;
&lt;h2 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h2&gt;&lt;p&gt;基础的通讯模型，服务器A和服务器B相互之间的通讯不公用一条通道，分别用两条通道来进行单边通讯。进一步升级后，两个服务器可以共用同一条通道来进行字节流的读写，其中一方断开连接后，另一方也会收到&lt;code&gt;connection reset by pee&lt;/code&gt;断开链接的消息，然后讲了几个应用场景。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Stanford" scheme="http://blog.peiel.com/tags/Stanford/"/>
    
      <category term="Network" scheme="http://blog.peiel.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>Two Sum 最优解的解读</title>
    <link href="http://blog.peiel.com/2019/12/23/Two-Sum-%E6%9C%80%E4%BC%98%E8%A7%A3%E7%9A%84%E8%A7%A3%E8%AF%BB/"/>
    <id>http://blog.peiel.com/2019/12/23/Two-Sum-最优解的解读/</id>
    <published>2019-12-23T15:24:28.000Z</published>
    <updated>2019-12-23T16:01:43.148Z</updated>
    
    <content type="html"><![CDATA[<p>LeetCode 上 Two Sum 问题，自己能想到的是双循环的暴力解决法和使用单 Hash Table 来解决。看到有大神写的代码TestCase跑时间消耗为0ms，拜读分析一下。</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>代码如下:（ <a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">点击在LeetCode答案分析中时间消耗排行中查找</a>）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="number">2048</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2048</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key = target - nums[i] &amp; mod;</span><br><span class="line">        <span class="keyword">if</span>(map[key] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] ret = &#123;map[key]-<span class="number">1</span>, i&#125;;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        map[nums[i]&amp;mod] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单分析一下，主要有以下要点：</p><ul><li>创建了一个2048长度的槽（数组）</li><li>对目标值和查找值进行按位与运算得到一个索引值</li><li>根据索引值对应的槽来查找是否是符合</li><li>如果不符合的下标值，就把当前值按位与计算找到槽，把槽中的值加一。</li></ul><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><ul><li>为什么槽的长度定义在2048？</li><li>2048个槽理论上来讲会存在碰撞问题，碰撞可能出现，出现后会误判。（可是没举出碰撞出现问题的例子来）</li><li>如何基于时间复杂度分析，来分析为什么这个算法运行快？</li></ul><p>写的有错误的地方欢迎指出，也欢迎留言一起讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LeetCode 上 Two Sum 问题，自己能想到的是双循环的暴力解决法和使用单 Hash Table 来解决。看到有大神写的代码TestCase跑时间消耗为0ms，拜读分析一下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithms" scheme="http://blog.peiel.com/tags/Algorithms/"/>
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java位运算</title>
    <link href="http://blog.peiel.com/2019/12/23/Java%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://blog.peiel.com/2019/12/23/Java位运算/</id>
    <published>2019-12-23T13:29:52.000Z</published>
    <updated>2019-12-23T13:31:12.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-位运算"><a href="#Java-位运算" class="headerlink" title="Java 位运算"></a>Java 位运算</h1><ul><li><code>&lt;&lt;</code> 左移</li><li><code>&gt;&gt;</code> 右移</li><li><code>&gt;&gt;&gt;</code> 无符号右移</li><li><code>&amp;</code> 位与</li><li><code>|</code> 位或</li><li><code>^</code> 位异或</li><li><code>~</code> 位非</li></ul><a id="more"></a><p>通过 Java <code>int</code> 来举例。</p><h2 id="代码输出结果查看"><a href="#代码输出结果查看" class="headerlink" title="代码输出结果查看"></a>代码输出结果查看</h2><h3 id="左移操作"><a href="#左移操作" class="headerlink" title="左移操作"></a>左移操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">左移2位的结果 的二进制        : 0000 0000 0000 0000 0000 0000 0001 0100</span><br><span class="line">-5 的二进制                 : 1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line">左移2位的结果 的二进制        : 1111 1111 1111 1111 1111 1111 1110 1100</span><br></pre></td></tr></table></figure><h3 id="右移操作"><a href="#右移操作" class="headerlink" title="右移操作"></a>右移操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">右移2位的结果 的二进制        : 0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-5 的二进制                 : 1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line">右移2位的结果 的二进制        : 1111 1111 1111 1111 1111 1111 1111 1110</span><br></pre></td></tr></table></figure><h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">无符号右移2位的结果 的二进制   : 0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line">-5 的二进制                 : 1111 1111 1111 1111 1111 1111 1111 1011</span><br><span class="line">无符号右移2位的结果 的二进制   : 0011 1111 1111 1111 1111 1111 1111 1110</span><br></pre></td></tr></table></figure><h3 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">7 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">5 &amp; 7 = 的二进制            : 0000 0000 0000 0000 0000 0000 0000 0101</span><br></pre></td></tr></table></figure><h3 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">7 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">5 | 7 = 的二进制            : 0000 0000 0000 0000 0000 0000 0000 0111</span><br></pre></td></tr></table></figure><h3 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">7 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0111</span><br><span class="line">5 ^ 7 = 的二进制            : 0000 0000 0000 0000 0000 0000 0000 0010</span><br></pre></td></tr></table></figure><h3 id="按位非"><a href="#按位非" class="headerlink" title="按位非"></a>按位非</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 的二进制                  : 0000 0000 0000 0000 0000 0000 0000 0101</span><br><span class="line">~5的二进制                  : 1111 1111 1111 1111 1111 1111 1111 1010</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><a href="https://github.com/peiel/Java-Notes/blob/master/src/main/java/com/peierlong/base/BitExercises.java" target="_blank" rel="noopener">点击链接跳转GitHub查看</a></p><h2 id="需要注意的点"><a href="#需要注意的点" class="headerlink" title="需要注意的点"></a>需要注意的点</h2><p>无符号右移无论正负数，高位都会补零。<br>有符号右移会根据本身的正负数来进行填充。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-位运算&quot;&gt;&lt;a href=&quot;#Java-位运算&quot; class=&quot;headerlink&quot; title=&quot;Java 位运算&quot;&gt;&lt;/a&gt;Java 位运算&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 左移&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 右移&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 无符号右移&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 位与&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt; 位或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 位异或&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 位非&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="BitOperation" scheme="http://blog.peiel.com/tags/BitOperation/"/>
    
  </entry>
  
  <entry>
    <title>GitHub图片加载不稳定解决办法</title>
    <link href="http://blog.peiel.com/2019/12/19/GitHub%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%B8%8D%E7%A8%B3%E5%AE%9A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://blog.peiel.com/2019/12/19/GitHub图片加载不稳定解决办法/</id>
    <published>2019-12-19T03:25:41.000Z</published>
    <updated>2019-12-19T03:32:30.499Z</updated>
    
    <content type="html"><![CDATA[<p>打开控制台，发现图片的Get请求部分请求被拒绝。<br><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/oMNqFJ.png" alt="img"></p><h2 id="分析原因："><a href="#分析原因：" class="headerlink" title="分析原因："></a>分析原因：</h2><ol><li>有可能时本地代理拦截了请求</li><li>有可能DNS被污染了</li></ol><h2 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h2><ol><li>检查修改本地代理的配置</li><li>配置host</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打开控制台，发现图片的Get请求部分请求被拒绝。&lt;br&gt;&lt;img src=&quot;http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/oMNqFJ.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析原因：&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="GitHub" scheme="http://blog.peiel.com/categories/GitHub/"/>
    
    
      <category term="Git" scheme="http://blog.peiel.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>IDEA CodeGlance插件不显示无效不起作用的解决方案</title>
    <link href="http://blog.peiel.com/2019/10/31/IDEA-CodeGlance%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%97%A0%E6%95%88%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.peiel.com/2019/10/31/IDEA-CodeGlance不显示无效不起作用的解决方案/</id>
    <published>2019-10-31T07:45:53.000Z</published>
    <updated>2019-12-19T03:33:41.271Z</updated>
    
    <content type="html"><![CDATA[<ol><li>首先查看是否安装成功，并且插件处于开启状态。</li><li>使用快捷键 <code>ctrl + shift + G</code> 或者 <code>cmd + shift + G</code>，查看是否有效果。</li><li>如果还不行，点击菜单 <code>IntelliJ IDEA &gt; Preferences</code> ，<code>Other Settings &gt; CodeGlance</code>，把其中 <code>Disabled</code> 选项对勾去掉。如下图。</li></ol><a id="more"></a><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/OLYEiP.jpg" alt="CodeGlance"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;首先查看是否安装成功，并且插件处于开启状态。&lt;/li&gt;
&lt;li&gt;使用快捷键 &lt;code&gt;ctrl + shift + G&lt;/code&gt; 或者 &lt;code&gt;cmd + shift + G&lt;/code&gt;，查看是否有效果。&lt;/li&gt;
&lt;li&gt;如果还不行，点击菜单 &lt;code&gt;IntelliJ IDEA &amp;gt; Preferences&lt;/code&gt; ，&lt;code&gt;Other Settings &amp;gt; CodeGlance&lt;/code&gt;，把其中 &lt;code&gt;Disabled&lt;/code&gt; 选项对勾去掉。如下图。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="-IDEA" scheme="http://blog.peiel.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>Redis RDB 持久化错误解决</title>
    <link href="http://blog.peiel.com/2019/06/25/Redis-RDB-%E6%8C%81%E4%B9%85%E5%8C%96%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
    <id>http://blog.peiel.com/2019/06/25/Redis-RDB-持久化错误解决/</id>
    <published>2019-06-25T12:43:30.000Z</published>
    <updated>2019-12-19T03:33:41.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>Java process log output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. </span><br><span class="line">Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.; nested exception is redis.clients.jedis.exceptions.JedisDataException: MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.</span><br></pre></td></tr></table></figure><a id="more"></a><p>Redis log output：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5459:M 25 Jun 11:05:55.025 * 1 changes in 900 seconds. Saving...</span><br><span class="line">5459:M 25 Jun 11:05:55.025 # Can&apos;t save in background: fork: Cannot allocate memory</span><br></pre></td></tr></table></figure><p>The monitoring system:</p><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/df_free.jpg" alt="df_free.jpg"><br><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/mem_free.jpg" alt="mem_free.jpg"></p><p>红色线为 Redis Server 端，蓝色线为连接 Redis 的客户端。可以看到，客户端硬盘和内存的压力都很大，服务端内存也只剩余大约 30% 。</p><h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>在 Java 客户端输出的日志上，报错的意思是无法在磁盘进行RDB快照持久化，但是在监控系统中 Redis 所在服务器磁盘并没有压力，可以排除磁盘满而无法进行持久化。</p><p>根据 Redis 的报错 <code>Can&#39;t save in background: fork: Cannot allocate memory</code>信息，查看 Redis 相关文档，此报错原因试因为 <code>stop-writes-on-bgsave-error yes</code> 参数而产生的报错，在RDB持久化的进程执行持久化时，Redis 不允许用户进行任何更新操作，与 Java 中的错误日志吻合。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h3 id="1-修改Reids参数-stop-writes-on-bgsave-error-false"><a href="#1-修改Reids参数-stop-writes-on-bgsave-error-false" class="headerlink" title="1. 修改Reids参数 stop-writes-on-bgsave-error false"></a>1. 修改Reids参数 <code>stop-writes-on-bgsave-error false</code></h3><p>在 RDB持久化 出错时，允许用户继续操作。这种方式并没有解决真正的报错，我们来看第二种方式。</p><h3 id="2-修改内核参数，在-etc-sysctl-conf-添加-vm-overcommit-memory-1，使用sysctl-p刷新生效。"><a href="#2-修改内核参数，在-etc-sysctl-conf-添加-vm-overcommit-memory-1，使用sysctl-p刷新生效。" class="headerlink" title="2. 修改内核参数，在 /etc/sysctl.conf 添加 vm.overcommit_memory=1，使用sysctl -p刷新生效。"></a>2. 修改内核参数，在 <code>/etc/sysctl.conf</code> 添加 <code>vm.overcommit_memory=1</code>，使用<code>sysctl -p</code>刷新生效。</h3><p>如图，修改后，Redis自动恢复。<br><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/log.jpg" alt="log.jpg"></p><p>下面我们来分析一下这个参数</p><h4 id="首先，这个参数涉及到了在什么情况下，Linux会内存不足？"><a href="#首先，这个参数涉及到了在什么情况下，Linux会内存不足？" class="headerlink" title="首先，这个参数涉及到了在什么情况下，Linux会内存不足？"></a>首先，这个参数涉及到了在什么情况下，Linux会内存不足？</h4><p>Linux 下 CommitLimit 的大小用来限制用户态可使用的内存资源，通过命令<code>grep -i commit /proc/meminfo</code>，<code>CommitLimit</code>表示内存分配上限，<code>Committed-AS</code>表示已经分配的内存大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommitLimit = 物理内存 * overcommit_ratio(/proc/sys/vm/overcommit_ratio) + swap</span><br></pre></td></tr></table></figure><p>当满足下方公式时，系统就会认为内存不足。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序申请内存 + 系统已经分配的内存(Committed-AS) &gt; CommitLimit</span><br></pre></td></tr></table></figure><h4 id="其次，当满足内存不足时，操作系统根据overcommit-memory参数来执行不同的策略。"><a href="#其次，当满足内存不足时，操作系统根据overcommit-memory参数来执行不同的策略。" class="headerlink" title="其次，当满足内存不足时，操作系统根据overcommit_memory参数来执行不同的策略。"></a>其次，当满足内存不足时，操作系统根据<code>overcommit_memory</code>参数来执行不同的策略。</h4><ul><li>vm.overcommit_memory = 0 启发策略</li></ul><p>比较 <code>请求分配的内存 &gt; 系统空闲内存 + swap</code> 如果满足，则虚拟地址空间分配失败。 </p><ul><li>vm.overcommit_memory = 1 允许 overcommit</li></ul><p>直接放行，不进行任何校验，任何情况下系统都会为应用程序分配虚拟内存空间。<br><strong>弊端</strong>：完全屏蔽了应用程序对系统物理内存的感知，当发生缺页中断的机制来进行分配内存，一旦内存分配失败，会引起系统OOM机制杀进程。</p><ul><li>vm.overcommit_memory = 2 禁止 overcommit</li></ul><p>这种情况下系统所能分配的内存不会超过上面提到的 <code>CommitLimit</code> 大小，如果资源用光，任何尝试分配内存的行为都会失败，也就是说不能运行任何新的进程。</p><h4 id="最后，对-Redis-产生了什么影响"><a href="#最后，对-Redis-产生了什么影响" class="headerlink" title="最后，对 Redis 产生了什么影响"></a>最后，对 Redis 产生了什么影响</h4><p>Redis 异步 BGSAVE 命令，主进程 fork 后，复制自身并通过这个新的进程来持久化到磁盘，完毕后进程自动关闭。</p><p>如果Redis分配的内存太大，在 fork 进程的时候，容易发生内存不足无法fork的情况。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol><li>我们平时在使用Rdis的时候，一定要记得给缓存设置有效时间，避免非热点数据占用内存。</li><li>Redis的RDB快照持久化需要fork新的进程，在内存占用大时，fork的代价极大。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;Java process log output:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.; nested exception is redis.clients.jedis.exceptions.JedisDataException: MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.peiel.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://blog.peiel.com/tags/Redis/"/>
    
      <category term="缓存" scheme="http://blog.peiel.com/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="RDB" scheme="http://blog.peiel.com/tags/RDB/"/>
    
  </entry>
  
  <entry>
    <title>递归的理解</title>
    <link href="http://blog.peiel.com/2019/04/12/%E9%80%92%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.peiel.com/2019/04/12/递归的理解/</id>
    <published>2019-04-12T12:33:17.000Z</published>
    <updated>2019-04-18T02:37:11.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h2><p>方法或函数调用自身的方式称之为递归，调用成为递，返回称为归。</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>优点：代码简洁表达能力强。<br>缺点：空间复杂度高，栈溢出，存在重复计算。</p><a id="more"></a><h2 id="递归使用场景"><a href="#递归使用场景" class="headerlink" title="递归使用场景"></a>递归使用场景</h2><p>满足以下三个条件，就可以使用递归：</p><ol><li>问题的解可以分解为几个子问题的解，何为子问题？就是数据规模更小的问题。</li><li>问题与子问题，除了数据规模不同，求解思路完全一样。</li><li>存在递归终止条件。</li></ol><h2 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h2><h3 id="1-编写"><a href="#1-编写" class="headerlink" title="1. 编写"></a>1. 编写</h3><p>关键是找到如何将大问题分解为小问题的规律，写出递归公式，推敲终止条件，最后翻译成实际的代码。</p><h3 id="2-理解"><a href="#2-理解" class="headerlink" title="2. 理解"></a>2. 理解</h3><p>避免思维误区：不要试图去想清楚整个递和归的过程。<br>那怎么想？如果问题 A 可以分解为 B、C、D 三个子问题，可以假设 B、C、D 已经解决。只需要思考问题 A 和 子问题之间的关系即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是递归&quot;&gt;&lt;a href=&quot;#什么是递归&quot; class=&quot;headerlink&quot; title=&quot;什么是递归&quot;&gt;&lt;/a&gt;什么是递归&lt;/h2&gt;&lt;p&gt;方法或函数调用自身的方式称之为递归，调用成为递，返回称为归。&lt;/p&gt;
&lt;h2 id=&quot;优缺点&quot;&gt;&lt;a href=&quot;#优缺点&quot; class=&quot;headerlink&quot; title=&quot;优缺点&quot;&gt;&lt;/a&gt;优缺点&lt;/h2&gt;&lt;p&gt;优点：代码简洁表达能力强。&lt;br&gt;缺点：空间复杂度高，栈溢出，存在重复计算。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://blog.peiel.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://blog.peiel.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>《暗时间》读书笔记</title>
    <link href="http://blog.peiel.com/2019/04/11/%E3%80%8A%E6%9A%97%E6%97%B6%E9%97%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.peiel.com/2019/04/11/《暗时间》读书笔记/</id>
    <published>2019-04-11T12:15:50.000Z</published>
    <updated>2019-04-12T02:16:30.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《暗时间》读书笔记"><a href="#《暗时间》读书笔记" class="headerlink" title="《暗时间》读书笔记"></a>《暗时间》读书笔记</h1><h2 id="什么是暗时间？"><a href="#什么是暗时间？" class="headerlink" title="什么是暗时间？"></a>什么是暗时间？</h2><p>简单来讲，就是我们对时间利用的效率，在一般情况下，我们在做某一些事的时候，几乎不用大脑来思考，这个时候利用这个时间来思考一些事情，我们的时间的效率就会提高。</p><a id="more"></a><h2 id="学习和思考"><a href="#学习和思考" class="headerlink" title="学习和思考"></a>学习和思考</h2><ul><li>看书只看经典</li><li>笔记 &amp; 博客</li><li>Google &amp; wiki</li><li>重要的事情优先做</li></ul><h2 id="阅读和思考"><a href="#阅读和思考" class="headerlink" title="阅读和思考"></a>阅读和思考</h2><ul><li>有的地方快点儿读，有的地方慢点读。</li><li>重点知识点多本书联合起来一起读。</li><li>“三天打渔，俩天晒网。”会变成“天天晒网，永不打渔。”</li></ul><p>end！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;《暗时间》读书笔记&quot;&gt;&lt;a href=&quot;#《暗时间》读书笔记&quot; class=&quot;headerlink&quot; title=&quot;《暗时间》读书笔记&quot;&gt;&lt;/a&gt;《暗时间》读书笔记&lt;/h1&gt;&lt;h2 id=&quot;什么是暗时间？&quot;&gt;&lt;a href=&quot;#什么是暗时间？&quot; class=&quot;headerlink&quot; title=&quot;什么是暗时间？&quot;&gt;&lt;/a&gt;什么是暗时间？&lt;/h2&gt;&lt;p&gt;简单来讲，就是我们对时间利用的效率，在一般情况下，我们在做某一些事的时候，几乎不用大脑来思考，这个时候利用这个时间来思考一些事情，我们的时间的效率就会提高。&lt;/p&gt;
    
    </summary>
    
      <category term="读书" scheme="http://blog.peiel.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>Java NIO 之 FileChannel 的使用</title>
    <link href="http://blog.peiel.com/2019/03/22/Java-NIO-%E4%B9%8B-FileChannel-%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.peiel.com/2019/03/22/Java-NIO-之-FileChannel-的使用/</id>
    <published>2019-03-22T13:19:11.000Z</published>
    <updated>2019-03-22T08:20:26.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通过文件获取-FileChannel-实例"><a href="#通过文件获取-FileChannel-实例" class="headerlink" title="通过文件获取 FileChannel 实例"></a>通过文件获取 FileChannel 实例</h2><h3 id="1-从-FileInputstream-中获取"><a href="#1-从-FileInputstream-中获取" class="headerlink" title="1. 从 FileInputstream 中获取"></a>1. 从 FileInputstream 中获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"/Users/peiel/a.txt"</span>);</span><br><span class="line">FileChannel fileChannel = fis.getChannel();</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-使用-RandomAccessFile-获取"><a href="#2-使用-RandomAccessFile-获取" class="headerlink" title="2. 使用 RandomAccessFile 获取"></a>2. 使用 RandomAccessFile 获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fis = <span class="keyword">new</span> RandomAccessFile(<span class="string">"/Users/peiel/a.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fileChannel = fis.getChannel();</span><br></pre></td></tr></table></figure><h2 id="打印读取-FileChannel-中的内容"><a href="#打印读取-FileChannel-中的内容" class="headerlink" title="打印读取 FileChannel 中的内容"></a>打印读取 FileChannel 中的内容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span> ((len = fileChannel.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// flip buf (limit = position; position = 0;)</span></span><br><span class="line">    buf.flip();</span><br><span class="line">    <span class="comment">// 方式一：转换成数组读取的方式</span></span><br><span class="line">    System.out.print(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</span><br><span class="line">    <span class="comment">// 方式二：直接读取的方式</span></span><br><span class="line">    <span class="keyword">while</span> (buf.hasRemaining()) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// clear    </span></span><br><span class="line">    buf.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写入数据到文件中"><a href="#写入数据到文件中" class="headerlink" title="写入数据到文件中"></a>写入数据到文件中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"This is a boy!"</span>;</span><br><span class="line"></span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">byteBuffer.clear();</span><br><span class="line">byteBuffer.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">byteBuffer.flip();</span><br><span class="line"><span class="keyword">while</span> (byteBuffer.hasRemaining()) &#123;</span><br><span class="line">    fileChannel.write(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通过文件获取-FileChannel-实例&quot;&gt;&lt;a href=&quot;#通过文件获取-FileChannel-实例&quot; class=&quot;headerlink&quot; title=&quot;通过文件获取 FileChannel 实例&quot;&gt;&lt;/a&gt;通过文件获取 FileChannel 实例&lt;/h2&gt;&lt;h3 id=&quot;1-从-FileInputstream-中获取&quot;&gt;&lt;a href=&quot;#1-从-FileInputstream-中获取&quot; class=&quot;headerlink&quot; title=&quot;1. 从 FileInputstream 中获取&quot;&gt;&lt;/a&gt;1. 从 FileInputstream 中获取&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;FileInputStream fis = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FileInputStream(&lt;span class=&quot;string&quot;&gt;&quot;/Users/peiel/a.txt&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FileChannel fileChannel = fis.getChannel();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://blog.peiel.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 问题修复记录</title>
    <link href="http://blog.peiel.com/2019/03/12/hexo-problem-fix/"/>
    <id>http://blog.peiel.com/2019/03/12/hexo-problem-fix/</id>
    <published>2019-03-12T13:37:52.000Z</published>
    <updated>2019-03-14T02:07:06.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h2><ol><li><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash</code></li><li>配置环境变量</li></ol><a id="more"></a><h2 id="使用-nvm-快捷安装-node"><a href="#使用-nvm-快捷安装-node" class="headerlink" title="使用 nvm 快捷安装 node"></a>使用 nvm 快捷安装 node</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 6.17.0</span><br></pre></td></tr></table></figure><h2 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h2><h3 id="错误1"><a href="#错误1" class="headerlink" title="错误1"></a>错误1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Plugin load failed: hexo-renderer-sass</span><br></pre></td></tr></table></figure><h3 id="解决1"><a href="#解决1" class="headerlink" title="解决1"></a>解决1</h3><p>使用brew安装系统 <code>libsass</code> 依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew reinstall libsass</span><br></pre></td></tr></table></figure><h3 id="错误2"><a href="#错误2" class="headerlink" title="错误2"></a>错误2</h3><p>node版本与编译版本不一致导致失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Error: The module &apos;/usr/local/lib/node_modules/hexo/node_modules/dtrace-provider/build/Release/DTraceProviderBindings.node&apos;</span><br><span class="line">was compiled against a different Node.js version using</span><br><span class="line">NODE_MODULE_VERSION 48. This version of Node.js requires</span><br><span class="line">NODE_MODULE_VERSION 67. Please try re-compiling or re-installing</span><br></pre></td></tr></table></figure><h3 id="解决2"><a href="#解决2" class="headerlink" title="解决2"></a>解决2</h3><p>根据错误日志，查看版本号48的node版本，<a href="https://nodejs.org/zh-cn/download/releases/" target="_blank" rel="noopener">点击查看链接</a></p><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/node_verison.jpg" alt="node_verison.jpg"></p><p>使用nvm安装对应版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install 6.17.0</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>hexo 不能使用的主要原因还是设备更换的原因，更换设备注意同步node版本，环境依赖，就不会出问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装-nvm&quot;&gt;&lt;a href=&quot;#安装-nvm&quot; class=&quot;headerlink&quot; title=&quot;安装 nvm&quot;&gt;&lt;/a&gt;安装 nvm&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置环境变量&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.peiel.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://blog.peiel.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>我的书单</title>
    <link href="http://blog.peiel.com/2019/02/14/%E6%88%91%E7%9A%84%E4%B9%A6%E5%8D%95/"/>
    <id>http://blog.peiel.com/2019/02/14/我的书单/</id>
    <published>2019-02-14T11:56:04.000Z</published>
    <updated>2019-03-14T02:02:22.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言相关"><a href="#语言相关" class="headerlink" title="语言相关"></a>语言相关</h2><ul><li>《Java编程思想》</li><li>《深入理解JVM》★★★★★</li></ul><a id="more"></a><ul><li>《Java 并发编程实战》★★★★★</li><li>《深入理解Java虚拟机》★★★★★</li><li>《Effective Java》★★★★★</li><li>《Head First Python》</li><li>《C程序设计语言(第二版新版)》</li><li>《汇编语言(第三版)》</li><li>《深入分析Java Web技术内幕》</li><li>《Java并发编程的艺术》★★★★☆</li></ul><h2 id="计算机基础与网络"><a href="#计算机基础与网络" class="headerlink" title="计算机基础与网络"></a>计算机基础与网络</h2><ul><li>《深入理解计算机系统》</li><li><a href="http://book.douban.com/subject/6097773/" target="_blank" rel="noopener">《Linux内核设计与实现 第3版》</a></li><li><a href="http://book.douban.com/subject/26268767/" target="_blank" rel="noopener">《WireShark网络分析就这么简单》</a></li><li><a href="http://book.douban.com/subject/26710788/" target="_blank" rel="noopener">《WireShark网络分析的艺术》</a></li><li>《TCP/IP详解(卷一：协议)》</li><li>《图解TCP/IP(第五版)》 </li><li>《HTTP权威指南》</li><li>《程序员的数学》（1基础 2统计 3线性代数）</li></ul><h2 id="开源框架与具体技术"><a href="#开源框架与具体技术" class="headerlink" title="开源框架与具体技术"></a>开源框架与具体技术</h2><ul><li>《Hadoop权威指南》</li><li>《Netty权威指南》</li><li>《从PAXOS到ZOOKEEPER分布式一致性原理与实践》</li><li><a href="http://book.douban.com/subject/26593175/" target="_blank" rel="noopener">《Docker: 容器与容器云》</a></li><li><a href="http://book.douban.com/subject/26702824/" target="_blank" rel="noopener">《分布式服务框架：原理与实践》</a></li><li><a href="http://book.douban.com/subject/26649141/" target="_blank" rel="noopener">《Spark技术内幕》</a></li><li>《Mastering Nginx 2nd Edition》</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>《亿级流量网站架构核心技术》 </li><li>《大型网站技术架构》</li><li>《大型分布式网站架构设计与实践》</li><li>《大型网站系统与Java中间件实践》</li></ul><h2 id="算法与数据结构-amp-设计模式"><a href="#算法与数据结构-amp-设计模式" class="headerlink" title="算法与数据结构 &amp; 设计模式"></a>算法与数据结构 &amp; 设计模式</h2><ul><li>《算法导论》</li><li>《数据结构与算法分析(Java语言描述)》</li><li>《算法4》</li></ul><ul><li>《Head First 设计模式》</li></ul><h2 id="数据库与缓存"><a href="#数据库与缓存" class="headerlink" title="数据库与缓存"></a>数据库与缓存</h2><ul><li>《Redis入门指南》</li><li><a href="http://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现分析》</a></li><li>《MongoDB权威指南》</li><li>《MySQL技术内幕  InnoDB存储引擎  第2版》 </li><li>《高性能MySql》★★★★★</li></ul><h2 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h2><ul><li>《Clean Code》</li><li>《敏捷软件开发》</li><li>《重构》</li><li>《程序员修炼之道-从小工到专家》</li><li>《代码大全2》</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>《HTML秘籍》</li><li>《JavaScript权威指南（第六版）》</li><li>《了不起的Node.js》</li><li>《Node.js开发指南》</li><li>《深入浅出Node.js》</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>《技术之瞳》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;语言相关&quot;&gt;&lt;a href=&quot;#语言相关&quot; class=&quot;headerlink&quot; title=&quot;语言相关&quot;&gt;&lt;/a&gt;语言相关&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;《Java编程思想》&lt;/li&gt;
&lt;li&gt;《深入理解JVM》★★★★★&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书" scheme="http://blog.peiel.com/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="书单" scheme="http://blog.peiel.com/tags/%E4%B9%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot2.x整合ES2.x报failed to load elasticsearch nodes</title>
    <link href="http://blog.peiel.com/2018/07/18/SpringBoot2.x%E6%95%B4%E5%90%88ES2.x%E6%8A%A5failed-to-load-elasticsearch-nodes/"/>
    <id>http://blog.peiel.com/2018/07/18/SpringBoot2.x整合ES2.x报failed-to-load-elasticsearch-nodes/</id>
    <published>2018-07-18T02:26:16.000Z</published>
    <updated>2019-03-13T02:32:01.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在SpringBoot整合ES时，遇到如下错误。"><a href="#在SpringBoot整合ES时，遇到如下错误。" class="headerlink" title="在SpringBoot整合ES时，遇到如下错误。"></a>在SpringBoot整合ES时，遇到如下错误。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 2075 --- [           main] .d.e.r.s.AbstractElasticsearchRepository : failed to load elasticsearch nodes : org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available:</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><p><code>pom.xml</code>部分配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><code>application.properties</code> ES相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.data.elasticsearch.repositories.enabled=true</span><br><span class="line">spring.data.elasticsearch.cluster-nodes=192.168.xxx.xxx\:9300</span><br></pre></td></tr></table></figure><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>SpringBoot2.0</li><li>ES2.4</li></ul><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>导致一直解决不了问题的原因是<a href="https://github.com/spring-projects/spring-data-elasticsearch/wiki/Spring-Data-Elasticsearch---Spring-Boot---version-matrix" target="_blank" rel="noopener">这个链接</a>显示SpringBoot2.0是兼容ES2.4的，所以我首先排除了兼容问题。</p><p>网上查找，报这个错的原因是因为IP限制，无论是修改ES的配置中<code>network.host</code>属性为<code>0.0.0.0</code>也好，我链接ES的机器的内网IP也好，<strong>都不好使</strong>。</p><p>之后看到了<a href="https://blog.csdn.net/lusyoe/article/details/80107865" target="_blank" rel="noopener">这篇文章</a>，我再次怀疑有可能版本兼容的问题，修改SpringBoot为<code>1.5.9.RELEASE</code>版本，不报错了。</p><p>这个兼容性问题，要么降级SpringBoot，要么升级ES，还是更新ES比较靠谱。</p><hr><blockquote><p>降级是不能降级的，这辈子都不可能降级</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;在SpringBoot整合ES时，遇到如下错误。&quot;&gt;&lt;a href=&quot;#在SpringBoot整合ES时，遇到如下错误。&quot; class=&quot;headerlink&quot; title=&quot;在SpringBoot整合ES时，遇到如下错误。&quot;&gt;&lt;/a&gt;在SpringBoot整合ES时，遇到如下错误。&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ERROR 2075 --- [           main] .d.e.r.s.AbstractElasticsearchRepository : failed to load elasticsearch nodes : org.elasticsearch.client.transport.NoNodeAvailableException: None of the configured nodes are available:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="ES" scheme="http://blog.peiel.com/tags/ES/"/>
    
      <category term="Spring" scheme="http://blog.peiel.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://blog.peiel.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient4.5.3源码浅析(HttpClient的execute方法执行过程)</title>
    <link href="http://blog.peiel.com/2018/06/29/HttpClient4-5-3%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(HttpClient%E7%9A%84execute%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B)/"/>
    <id>http://blog.peiel.com/2018/06/29/HttpClient4-5-3源码浅析(HttpClient的execute方法执行过程)/</id>
    <published>2018-06-29T07:07:03.000Z</published>
    <updated>2019-03-13T02:32:01.036Z</updated>
    
    <content type="html"><![CDATA[<p>上一遍总结的<code>HttpClient</code>对象的构造过程，本篇主要总结<code>HttpClient</code>对象的<code>execute()</code>方法的执行流程，我们先看整体的时序图（省略部分细节），然后一步步分析。当不知道流程的时候走debug也是不错的选择。</p><a id="more"></a><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/Xnip2018-06-180_15-08-22.jpg" alt="Xnip2018-06-180_15-08-22.jpg"></p><p>根据上一篇文章我们知道<code>HttpClient</code>实例是使用的子类<code>CloseableHttpClient</code>类初始化而来，所以我们看子类的<code>execute()</code>方法的源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpUriRequest request)</span> <span class="keyword">throws</span> IOException, ClientProtocolException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(request, (HttpContext) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CloseableHttpResponse <span class="title">execute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpUriRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException </span>&#123;</span><br><span class="line">    Args.notNull(request, <span class="string">"HTTP request"</span>);</span><br><span class="line">    <span class="keyword">return</span> doExecute(determineTarget(request), request, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> CloseableHttpResponse <span class="title">doExecute</span><span class="params">(HttpHost target, HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException</span>;</span><br></pre></td></tr></table></figure><p>我们看到调用链调用到了抽象方法<code>doExecute()</code>，上一篇中，我们知道<code>HttpClient</code>对象构建最后，是使用的<code>CloseableHttpClient</code>的子类<code>InternalHttpClient</code>创建的对象，所以我们来看<code>InternalHttpClient</code>类的<code>doExecute()</code>方法的具体实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> CloseableHttpResponse <span class="title">doExecute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpHost target,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> HttpContext context)</span> <span class="keyword">throws</span> IOException, ClientProtocolException </span>&#123;</span><br><span class="line">    Args.notNull(request, <span class="string">"HTTP request"</span>);</span><br><span class="line">    HttpExecutionAware execAware = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpExecutionAware) &#123;</span><br><span class="line">        execAware = (HttpExecutionAware) request;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> HttpRequestWrapper wrapper = HttpRequestWrapper.wrap(request, target);</span><br><span class="line">        <span class="keyword">final</span> HttpClientContext localcontext = HttpClientContext.adapt(</span><br><span class="line">                context != <span class="keyword">null</span> ? context : <span class="keyword">new</span> BasicHttpContext());</span><br><span class="line">        RequestConfig config = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Configurable) &#123;</span><br><span class="line">            config = ((Configurable) request).getConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> HttpParams params = request.getParams();</span><br><span class="line">            <span class="keyword">if</span> (params <span class="keyword">instanceof</span> HttpParamsNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!((HttpParamsNames) params).getNames().isEmpty()) &#123;</span><br><span class="line">                    config = HttpClientParamConfig.getRequestConfig(params, <span class="keyword">this</span>.defaultConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                config = HttpClientParamConfig.getRequestConfig(params, <span class="keyword">this</span>.defaultConfig);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            localcontext.setRequestConfig(config);</span><br><span class="line">        &#125;</span><br><span class="line">        setupContext(localcontext);</span><br><span class="line">        <span class="keyword">final</span> HttpRoute route = determineRoute(target, wrapper, localcontext);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.execChain.execute(route, wrapper, localcontext, execAware);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> HttpException httpException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClientProtocolException(httpException);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中</p><ol><li><code>HttpExecutionAware</code>类是用于接收阻塞I/O操作的通知。</li><li><code>HttpRequestWrapper</code>类是<code>HttpRequest</code>接口的包装类。</li><li><code>HttpClientContext</code>类实现<code>HttpContext</code>接口，表示HTTP进程的执行状态。</li><li><code>RequestConfig</code>请求配置类，初始化后赋值到了上下文<code>HttpClientContext</code>中。</li><li><code>HttpRoute</code>为路由类。想更深了解可以参考<a href="https://blog.csdn.net/zjysource/article/details/52945494" target="_blank" rel="noopener">这篇文章</a>。</li></ol><hr><p>接下来主要逻辑在<code>MainClientExec</code>的<code>execute()</code>方法，涉及到有关https的auth的内容暂时不做分析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request <span class="keyword">instanceof</span> HttpEntityEnclosingRequest) &#123;</span><br><span class="line">    RequestEntityProxy.enhance((HttpEntityEnclosingRequest) request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是<code>HttpEntityEnclosingRequest</code>类型的requet，则使用Entity代理类进行加强，主要用途是对entity的回收等操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object userToken = context.getUserToken();</span><br></pre></td></tr></table></figure><p>这是<code>HttpClient</code>标识，默认为null，为了保证用户使用链接的唯一性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConnectionRequest connRequest = connManager.requestConnection(route, userToken);</span><br></pre></td></tr></table></figure><p>得到一个由<code>connManager</code>管理其生命周期的<code>ConnectionRequest</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (execAware != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (execAware.isAborted()) &#123;</span><br><span class="line">            connRequest.cancel();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RequestAbortedException(<span class="string">"Request aborted"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            execAware.setCancellable(connRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>execAware</code>也实际表示一个封装请求。把当前链接赋值给<code>execAware</code>持有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RequestConfig config = context.getRequestConfig();</span><br></pre></td></tr></table></figure><p>从<code>context</code>中取出请求配置类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HttpClientConnection managedConn;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> timeout = config.getConnectionRequestTimeout();</span><br><span class="line">    managedConn = connRequest.get(timeout &gt; <span class="number">0</span> ? timeout : <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">final</span> InterruptedException interrupted) &#123;</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RequestAbortedException(<span class="string">"Request aborted"</span>, interrupted);</span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">final</span> ExecutionException ex) &#123;</span><br><span class="line">    Throwable cause = ex.getCause();</span><br><span class="line">    <span class="keyword">if</span> (cause == <span class="keyword">null</span>) &#123;</span><br><span class="line">        cause = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RequestAbortedException(<span class="string">"Request execution failed"</span>, cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>connRequest</code>得到一个<code>HttpClientConnection</code>，<code>HttpClientConnection</code> 可用于通过指定路由路径进行通信。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">context.setAttribute(HttpCoreContext.HTTP_CONNECTION, managedConn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (config.isStaleConnectionCheckEnabled()) &#123;</span><br><span class="line">        <span class="comment">// validate connection</span></span><br><span class="line">        <span class="keyword">if</span> (managedConn.isOpen()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.log.debug(<span class="string">"Stale connection check"</span>);</span><br><span class="line">            <span class="keyword">if</span> (managedConn.isStale()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.log.debug(<span class="string">"Stale connection detected"</span>);</span><br><span class="line">                managedConn.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>把<code>managedConn</code>放入<code>context</code>上下文中</li><li>对失效链接进行校验</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ConnectionHolder connHolder = <span class="keyword">new</span> ConnectionHolder(<span class="keyword">this</span>.log, <span class="keyword">this</span>.connManager, managedConn);</span><br></pre></td></tr></table></figure><p>创建一个链接持有者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (execAware != <span class="keyword">null</span>) &#123;</span><br><span class="line">                execAware.setCancellable(connHolder);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>使<code>execAware</code>请求<code>request</code>拥有链接持有者，这样用户可以对<code>request</code>可以直接对持有者进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> execCount = <span class="number">1</span>;; execCount++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (execCount &gt; <span class="number">1</span> &amp;&amp; !RequestEntityProxy.isRepeatable(request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NonRepeatableRequestException(<span class="string">"Cannot retry request "</span> +</span><br><span class="line">                        <span class="string">"with a non-repeatable request entity."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (execAware != <span class="keyword">null</span> &amp;&amp; execAware.isAborted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RequestAbortedException(<span class="string">"Request aborted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!managedConn.isOpen()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.log.debug(<span class="string">"Opening connection "</span> + route);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    establishRoute(proxyAuthState, managedConn, route, request, context);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> TunnelRefusedException ex) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.log.debug(ex.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    response = ex.getResponse();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> timeout = config.getSocketTimeout();</span><br><span class="line">            <span class="keyword">if</span> (timeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                managedConn.setSocketTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (execAware != <span class="keyword">null</span> &amp;&amp; execAware.isAborted()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RequestAbortedException(<span class="string">"Request aborted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.log.debug(<span class="string">"Executing request "</span> + request.getRequestLine());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 。。。 省略auth相关</span></span><br><span class="line"></span><br><span class="line">            response = requestExecutor.execute(request, managedConn, context);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The connection is in or can be brought to a re-usable state.</span></span><br><span class="line">            <span class="keyword">if</span> (reuseStrategy.keepAlive(response, context)) &#123;</span><br><span class="line">                <span class="comment">// Set the idle duration of this connection</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> duration = keepAliveStrategy.getKeepAliveDuration(response, context);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.log.isDebugEnabled()) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String s;</span><br><span class="line">                    <span class="keyword">if</span> (duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        s = <span class="string">"for "</span> + duration + <span class="string">" "</span> + TimeUnit.MILLISECONDS;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        s = <span class="string">"indefinitely"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">this</span>.log.debug(<span class="string">"Connection can be kept alive "</span> + s);</span><br><span class="line">                &#125;</span><br><span class="line">                connHolder.setValidFor(duration, TimeUnit.MILLISECONDS);</span><br><span class="line">                connHolder.markReusable();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                connHolder.markNonReusable();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 。。。 省略auth相关、</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这个代码块放在一个循环里边，循环的正常流程的终止条件在<code>needAuthentication()</code>判断中，暂不做分析。我们来对以上代码进行一个简要的分析：</p><ol><li>判断在第二次循环以后是否可以重复读，如果不可以重复读，则抛出异常。(不可重复读的指的是流，像<code>StringEntity</code> <code>FileEntity</code>这样的都是可以重复读的)</li><li>好几处地方都对<code>execAware</code>真正的<code>request</code>的是否终止<code>isAborted()</code>方法做校验，如果终止了，则抛出异常。有了这个我们就可以随时取消请求了。</li><li>如果链接不是open状态的，那么使用<code>route</code>路由对象重新建立一次链接。</li><li>对链接进行超时设置。</li><li>使用请求执行器<code>requestExecutor</code>执行请求得到<code>response</code>对象。</li><li>根据消息头判断链接是否要保持长链接，如果是，标记<code>connHolder</code>为可重用的，如果否，则标记为不可重用的。</li></ol><blockquote><p>注：在执行请求的时候，用到的<code>request</code>是<code>HttpRequestWrapper</code>包装类，使用包装类是防止真正的请求操作时发生改变。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (userToken == <span class="keyword">null</span>) &#123;</span><br><span class="line">            userToken = userTokenHandler.getUserToken(context);</span><br><span class="line">            context.setAttribute(HttpClientContext.USER_TOKEN, userToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">            connHolder.setState(userToken);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>把当前用户标识保存给链接持有者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check for entity, release connection if possible</span></span><br><span class="line"><span class="keyword">final</span> HttpEntity entity = response.getEntity();</span><br><span class="line"><span class="keyword">if</span> (entity == <span class="keyword">null</span> || !entity.isStreaming()) &#123;</span><br><span class="line">    <span class="comment">// connection not needed and (assumed to be) in re-usable state</span></span><br><span class="line">    connHolder.releaseConnection();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseProxy(response, <span class="keyword">null</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HttpResponseProxy(response, connHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从返回的<code>respnse</code>中得到<code>HttpEntity</code>，校验实体如果是空或者不是一个流，则释放链接。</li><li>使用<code>HttpResponseProxy</code>代理类对response进行代理，如果读取完了响应，那么这个响应就会关闭。</li></ol><hr><p>至此，<code>HttpClient</code>对象的<code>execute()</code>方法的简要的执行流程基本上就分析完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一遍总结的&lt;code&gt;HttpClient&lt;/code&gt;对象的构造过程，本篇主要总结&lt;code&gt;HttpClient&lt;/code&gt;对象的&lt;code&gt;execute()&lt;/code&gt;方法的执行流程，我们先看整体的时序图（省略部分细节），然后一步步分析。当不知道流程的时候走debug也是不错的选择。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://blog.peiel.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://blog.peiel.com/tags/Http/"/>
    
      <category term="HttpClient" scheme="http://blog.peiel.com/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient4.5.3源码浅析(HttpClient对象构造过程)</title>
    <link href="http://blog.peiel.com/2018/06/28/HttpClient4.5.3%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90(HttpClient%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B)/"/>
    <id>http://blog.peiel.com/2018/06/28/HttpClient4.5.3源码浅析(HttpClient构造过程)/</id>
    <published>2018-06-28T08:22:27.000Z</published>
    <updated>2019-03-13T02:32:01.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于现有的对<code>HttpClient</code>的工具类封装未形成统一的配置，针对线程池的配置也不全面，工具类的封装也没做到使用简洁合理回收，正好遇到<code>SpringMVC</code>向<code>SpringBoot</code>的迁移，于是对<code>HttpClient</code>进行一次重构，对<code>HttpClient</code>进行版本升级，并将相关配置分离出来管理。由于对<code>HttpClient</code>具体实现逻辑不是很清楚，所以有了这次的分析。</p><a id="more"></a><h1 id="分析目标"><a href="#分析目标" class="headerlink" title="分析目标"></a>分析目标</h1><ul><li>学习<code>HttpClient</code>的代码架构，了解实现方式和具体的调用方式。</li><li>学习<code>HttpClient</code>对线程池的支持以及<code>IdleConnectionEvictor</code>类对线程池中失效连接的清除。</li><li>学习<code>HttpClientBuilder</code>中对<code>HttpClient</code>的构建过程。</li></ul><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><h2 id="HttpClient接口实现结构"><a href="#HttpClient接口实现结构" class="headerlink" title="HttpClient接口实现结构"></a>HttpClient接口实现结构</h2><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/Xnip2018-06-179_16-24-12.jpg" alt="Xnip2018-06-179_16-24-12.jpg"></p><p><code>HttpClient</code>接口是<code>HttpClient</code>的核心接口，整个实现也是围绕着这个接口来做动作。</p><p><code>HttpClient</code>接口有三个实现类，其中<code>AutoRetryHttpClient</code>和<code>DecompressingHttpClient</code>在4.3版本标记为过期类，故不做分析，主要来看<code>CloseableHttpClient</code>类。</p><p><code>CloseableHttpClient</code>类是一个抽象类，它有三个子类，其中<code>AbstractHttpClient</code>为过期类，<code>MinimalHttpClient</code>是精简实现了，<code>InternalHttpClient</code>是主要实现。</p><h2 id="HttpClint的构造过程"><a href="#HttpClint的构造过程" class="headerlink" title="HttpClint的构造过程"></a>HttpClint的构造过程</h2><p>首先调用<code>HttpClients</code>类的<code>createDefault()</code>，根据注释和返回都能看出采用的<code>CloseableHttpClient</code>为默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates &#123;<span class="doctag">@link</span> CloseableHttpClient&#125; instance with default</span></span><br><span class="line"><span class="comment">     * configuration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CloseableHttpClient <span class="title">createDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HttpClientBuilder.create().build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其次通过<code>HttpClientBuilder.create()</code>创建<code>HttpClientBuilder</code>实例，并调用<code>build()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 照顾版面，省略中间各种配置代码</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InternalHttpClient(</span><br><span class="line">                execChain,</span><br><span class="line">                connManagerCopy,</span><br><span class="line">                routePlannerCopy,</span><br><span class="line">                cookieSpecRegistryCopy,</span><br><span class="line">                authSchemeRegistryCopy,</span><br><span class="line">                defaultCookieStore,</span><br><span class="line">                defaultCredentialsProvider,</span><br><span class="line">                defaultRequestConfig != <span class="keyword">null</span> ? defaultRequestConfig : RequestConfig.DEFAULT,</span><br><span class="line">                closeablesCopy);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们看到，返回的<code>CloseableHttpClient</code>实例使用<code>InternalHttpClient</code>类实现。</p><h2 id="HttpClient对线程池的支持方式"><a href="#HttpClient对线程池的支持方式" class="headerlink" title="HttpClient对线程池的支持方式"></a>HttpClient对线程池的支持方式</h2><p>HttpClientBuilder.java 类关于线程池部分源代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Assigns &#123;<span class="doctag">@link</span> HttpClientConnectionManager&#125; instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> HttpClientBuilder <span class="title">setConnectionManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpClientConnectionManager connManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connManager = connManager;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CloseableHttpClient <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        HttpClientConnectionManager connManagerCopy = <span class="keyword">this</span>.connManager;</span><br><span class="line">        <span class="keyword">if</span> (connManagerCopy == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LayeredConnectionSocketFactory sslSocketFactoryCopy = <span class="keyword">this</span>.sslSocketFactory;</span><br><span class="line">            <span class="keyword">if</span> (sslSocketFactoryCopy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> String[] supportedProtocols = systemProperties ? split(</span><br><span class="line">                        System.getProperty(<span class="string">"https.protocols"</span>)) : <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">final</span> String[] supportedCipherSuites = systemProperties ? split(</span><br><span class="line">                        System.getProperty(<span class="string">"https.cipherSuites"</span>)) : <span class="keyword">null</span>;</span><br><span class="line">                HostnameVerifier hostnameVerifierCopy = <span class="keyword">this</span>.hostnameVerifier;</span><br><span class="line">                <span class="keyword">if</span> (hostnameVerifierCopy == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    hostnameVerifierCopy = <span class="keyword">new</span> DefaultHostnameVerifier(publicSuffixMatcherCopy);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sslContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sslSocketFactoryCopy = <span class="keyword">new</span> SSLConnectionSocketFactory(</span><br><span class="line">                            sslContext, supportedProtocols, supportedCipherSuites, hostnameVerifierCopy);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (systemProperties) &#123;</span><br><span class="line">                        sslSocketFactoryCopy = <span class="keyword">new</span> SSLConnectionSocketFactory(</span><br><span class="line">                                (SSLSocketFactory) SSLSocketFactory.getDefault(),</span><br><span class="line">                                supportedProtocols, supportedCipherSuites, hostnameVerifierCopy);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sslSocketFactoryCopy = <span class="keyword">new</span> SSLConnectionSocketFactory(</span><br><span class="line">                                SSLContexts.createDefault(),</span><br><span class="line">                                hostnameVerifierCopy);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"resource"</span>)</span><br><span class="line">            <span class="keyword">final</span> PoolingHttpClientConnectionManager poolingmgr = <span class="keyword">new</span> PoolingHttpClientConnectionManager(</span><br><span class="line">                    RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span><br><span class="line">                        .register(<span class="string">"http"</span>, PlainConnectionSocketFactory.getSocketFactory())</span><br><span class="line">                        .register(<span class="string">"https"</span>, sslSocketFactoryCopy)</span><br><span class="line">                        .build(),</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">null</span>,</span><br><span class="line">                    dnsResolver,</span><br><span class="line">                    connTimeToLive,</span><br><span class="line">                    connTimeToLiveTimeUnit != <span class="keyword">null</span> ? connTimeToLiveTimeUnit : TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (defaultSocketConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                poolingmgr.setDefaultSocketConfig(defaultSocketConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (defaultConnectionConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                poolingmgr.setDefaultConnectionConfig(defaultConnectionConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (systemProperties) &#123;</span><br><span class="line">                String s = System.getProperty(<span class="string">"http.keepAlive"</span>, <span class="string">"true"</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">                    s = System.getProperty(<span class="string">"http.maxConnections"</span>, <span class="string">"5"</span>);</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> max = Integer.parseInt(s);</span><br><span class="line">                    poolingmgr.setDefaultMaxPerRoute(max);</span><br><span class="line">                    poolingmgr.setMaxTotal(<span class="number">2</span> * max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxConnTotal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                poolingmgr.setMaxTotal(maxConnTotal);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxConnPerRoute &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                poolingmgr.setDefaultMaxPerRoute(maxConnPerRoute);</span><br><span class="line">            &#125;</span><br><span class="line">            connManagerCopy = poolingmgr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>HttpClientBuilder</code>提供<code>setConnectionManager()</code>方法来传入一个<code>HttpClientConnectionManager</code>类型，而<code>HttpClientBuilder</code>可以通过<code>HttpClients.custom()</code>方法获得。</p><p>如果我们不传入自定义的<code>HttpClientConnectionManager</code>，在执行<code>build()</code>方法时会创建一个默认的线程池，代码参考<code>HttpClientBuilder</code>的<code>build()</code>方法。</p><h2 id="HttpClient对线程池失效链接的的处理"><a href="#HttpClient对线程池失效链接的的处理" class="headerlink" title="HttpClient对线程池失效链接的的处理"></a>HttpClient对线程池失效链接的的处理</h2><p>在4.4版本，提供了<code>IdleConnectionEvictor</code>类进行对失效线程和超时闲置线程的处理。主要实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.thread = <span class="keyword">this</span>.threadFactory.newThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                        Thread.sleep(sleepTimeMs);</span><br><span class="line">                        connectionManager.closeExpiredConnections();</span><br><span class="line">                        <span class="keyword">if</span> (maxIdleTimeMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            connectionManager.closeIdleConnections(maxIdleTimeMs, TimeUnit.MILLISECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception ex) &#123;</span><br><span class="line">                    exception = ex;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><p>简单来讲，实现原理是起一个后台线程，心跳检测，调用<code>connectionManager.closeExpiredConnections()</code>方法来进行失效回收，在<code>HttpClientBuilder</code>中有两个参数来控制是否启用失效回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> evictExpiredConnections;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> evictIdleConnections;</span><br></pre></td></tr></table></figure><p>在<code>build()</code>方法中调用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (evictExpiredConnections || evictIdleConnections) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleConnectionEvictor connectionEvictor = <span class="keyword">new</span> IdleConnectionEvictor(cm,</span><br><span class="line">                    maxIdleTime &gt; <span class="number">0</span> ? maxIdleTime : <span class="number">10</span>, maxIdleTimeUnit != <span class="keyword">null</span> ? maxIdleTimeUnit : TimeUnit.SECONDS);</span><br><span class="line">            closeablesCopy.add(<span class="keyword">new</span> Closeable() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                    connectionEvictor.shutdown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            connectionEvictor.start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h1><p>至此，对<code>HttpClient</code>的构造过程有所了解，下一篇主要学习一下HttpClient的execute()方法的执行过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;由于现有的对&lt;code&gt;HttpClient&lt;/code&gt;的工具类封装未形成统一的配置，针对线程池的配置也不全面，工具类的封装也没做到使用简洁合理回收，正好遇到&lt;code&gt;SpringMVC&lt;/code&gt;向&lt;code&gt;SpringBoot&lt;/code&gt;的迁移，于是对&lt;code&gt;HttpClient&lt;/code&gt;进行一次重构，对&lt;code&gt;HttpClient&lt;/code&gt;进行版本升级，并将相关配置分离出来管理。由于对&lt;code&gt;HttpClient&lt;/code&gt;具体实现逻辑不是很清楚，所以有了这次的分析。&lt;/p&gt;
    
    </summary>
    
      <category term="网络" scheme="http://blog.peiel.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="Http" scheme="http://blog.peiel.com/tags/Http/"/>
    
      <category term="HttpClient" scheme="http://blog.peiel.com/tags/HttpClient/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot读取配置文件方法</title>
    <link href="http://blog.peiel.com/2018/06/21/Spring-Boot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%96%B9%E6%B3%95/"/>
    <id>http://blog.peiel.com/2018/06/21/Spring-Boot读取配置文件方法/</id>
    <published>2018-06-21T06:32:50.000Z</published>
    <updated>2019-03-14T02:06:15.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-使用-Value方式读取，示例如下"><a href="#1-使用-Value方式读取，示例如下" class="headerlink" title="1. 使用@Value方式读取，示例如下"></a>1. 使用@Value方式读取，示例如下</h2><p>在 <code>application.properties</code> 中加入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test=123</span><br></pre></td></tr></table></figure><a id="more"></a><p>然后在类中可以使用@Value注解取值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Value(&quot;$&#123;test&#125;&quot;)</span><br><span class="line">private String test;</span><br></pre></td></tr></table></figure><h2 id="2-使用Environment方式取值"><a href="#2-使用Environment方式取值" class="headerlink" title="2. 使用Environment方式取值"></a>2. 使用Environment方式取值</h2><p>同样，以读取方式一中的配置文件内容为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private Environment env;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/test&quot;)</span><br><span class="line">public String test()&#123;</span><br><span class="line">    return env.getProperty(&quot;test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-自定义配置文件映射"><a href="#3-自定义配置文件映射" class="headerlink" title="3. 自定义配置文件映射"></a>3. 自定义配置文件映射</h2><p>在<code>application.properties</code>文件加入内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.name=zhangsan</span><br><span class="line">test.age=1</span><br></pre></td></tr></table></figure><p>新建实体 <code>Test.java</code>,内容如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以使用 <code>@PropertySource(&quot;classpath:my2.properties&quot;)</code> 指定读取的配置文件</p></blockquote><p>end！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-使用-Value方式读取，示例如下&quot;&gt;&lt;a href=&quot;#1-使用-Value方式读取，示例如下&quot; class=&quot;headerlink&quot; title=&quot;1. 使用@Value方式读取，示例如下&quot;&gt;&lt;/a&gt;1. 使用@Value方式读取，示例如下&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;application.properties&lt;/code&gt; 中加入如下内容&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;test=123&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://blog.peiel.com/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="http://blog.peiel.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>微信支付生成10位一天内不能重复的数字工具类</title>
    <link href="http://blog.peiel.com/2018/05/15/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E7%94%9F%E6%88%9010%E4%BD%8D%E4%B8%80%E5%A4%A9%E5%86%85%E4%B8%8D%E8%83%BD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://blog.peiel.com/2018/05/15/微信支付生成10位一天内不能重复的数字工具类/</id>
    <published>2018-05-15T08:00:15.000Z</published>
    <updated>2019-04-28T02:26:10.570Z</updated>
    
    <content type="html"><![CDATA[<p><br>在开发微信支付现金红包功能时遇到生成商户号的需要生成10位一天内不能重复的数字，如果用单纯的随机数，有可能随机数碰撞，产生相同商户号的问题，所以自己写了个工具类。</p><a id="more"></a><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String todayIndex = DateUtil.getSDFFDate();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商户订单号（每个订单号必须唯一）</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 组成：mch_id+yyyymmdd+10位一天内不能重复的数字</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> String <span class="title">generateRedPackMchBillno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!todayIndex.equals(DateUtil.getSDFFDate())) &#123;</span><br><span class="line">        list.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    String mchBillno = MAC_ID + DateUtil.getSDFFDate() + getRandomNumber();</span><br><span class="line">    <span class="keyword">if</span> (list.contains(mchBillno)) &#123;</span><br><span class="line">        <span class="keyword">return</span> generateRedPackMchBillno();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list.add(mchBillno);</span><br><span class="line">        todayIndex = DateUtil.getSDFFDate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mchBillno;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中由于代码存在多个竟态条件，如果不采取同步，在多线程条件下会存在线程安全问题，所以方法要同步。</p><p>DateUtil部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> SimpleDateFormat sdff = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSDFFDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sdff.format(<span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缺陷思考"><a href="#缺陷思考" class="headerlink" title="缺陷思考"></a>缺陷思考</h2><p>缓存的已经生成过的商户号在 JVM 重启的时候会重置，会导致有几率重复生成，所以需要把已经生成过的商户进行持久化缓存，可以借助开启持久化的 Redis 来进行缓存。</p><p>The end！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;br&gt;在开发微信支付现金红包功能时遇到生成商户号的需要生成10位一天内不能重复的数字，如果用单纯的随机数，有可能随机数碰撞，产生相同商户号的问题，所以自己写了个工具类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="WXPay" scheme="http://blog.peiel.com/tags/WXPay/"/>
    
  </entry>
  
  <entry>
    <title>Java ClassLodaer 知识总结</title>
    <link href="http://blog.peiel.com/2018/03/28/Java-ClassLodaer-%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.peiel.com/2018/03/28/Java-ClassLodaer-知识总结/</id>
    <published>2018-03-28T08:46:05.000Z</published>
    <updated>2019-03-13T02:32:01.037Z</updated>
    
    <content type="html"><![CDATA[<p>转载自<a href="http://ifeve.com/" target="_blank" rel="noopener">并发编程网 – ifeve.com</a>本文链接地址: <a href="http://ifeve.com/classloader/" target="_blank" rel="noopener">深入浅出ClassLoader</a></p><h1 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h1><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h1 id="违反双亲委派原则的例子"><a href="#违反双亲委派原则的例子" class="headerlink" title="违反双亲委派原则的例子"></a>违反双亲委派原则的例子</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载自&lt;a href=&quot;http://ifeve.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;并发编程网 – ifeve.com&lt;/a&gt;本文链接地址: &lt;a href=&quot;http://ifeve.com/classloader/&quot; target
      
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://blog.peiel.com/tags/JVM/"/>
    
      <category term="ClassLoader" scheme="http://blog.peiel.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Java字节码指令的分类</title>
    <link href="http://blog.peiel.com/2018/03/28/Java%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://blog.peiel.com/2018/03/28/Java字节码指令的分类/</id>
    <published>2018-03-28T07:36:30.000Z</published>
    <updated>2019-03-13T02:32:01.037Z</updated>
    
    <content type="html"><![CDATA[<p><strong>具有阅读字节码指令的能力对于理解Java语义有着重要的意义</strong></p><a id="more"></a><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/Xnip2018-03-87_15-35-04.jpg" alt="Xnip2018-03-87_15-35-04.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;具有阅读字节码指令的能力对于理解Java语义有着重要的意义&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://blog.peiel.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>阿里云文件上传Python脚本(自动复制MarkDown语法的图片至粘贴板)</title>
    <link href="http://blog.peiel.com/2018/03/13/%E9%98%BF%E9%87%8C%E4%BA%91%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0Python%E8%84%9A%E6%9C%AC-%E8%87%AA%E5%8A%A8%E5%A4%8D%E5%88%B6MarkDown%E8%AF%AD%E6%B3%95%E7%9A%84%E5%9B%BE%E7%89%87%E8%87%B3%E7%B2%98%E8%B4%B4%E6%9D%BF/"/>
    <id>http://blog.peiel.com/2018/03/13/阿里云文件上传Python脚本-自动复制MarkDown语法的图片至粘贴板/</id>
    <published>2018-03-13T05:07:40.000Z</published>
    <updated>2019-03-13T02:32:01.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="oss2mk"><a href="#oss2mk" class="headerlink" title="oss2mk"></a>oss2mk</h1><p>由于<code>MWeb</code>不支持阿里云图床，本脚本的主要功能时把图片上传到阿里云oss并把图片的markdown语法复制到粘贴板。</p><blockquote><p>GitHub地址: <a href="https://github.com/peierlong/oss2mk" target="_blank" rel="noopener">https://github.com/peierlong/oss2mk</a></p></blockquote><a id="more"></a><h2 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统          : macOS 10.13</span><br><span class="line">Python版本    : 3.6.1</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oss_2_mk.py [-absolute_path]</span><br></pre></td></tr></table></figure><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">执行:</span><br><span class="line">oss_2_mk.py /Users/elong/Desktop/war/gc_collector.jpg</span><br><span class="line">输出:</span><br><span class="line">obj_name : gc_collector.jpg</span><br><span class="line">start upload to oss ....</span><br><span class="line">end upload to oss</span><br><span class="line">please CMD + v to paste markdown img grammar</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> oss2</span><br><span class="line"></span><br><span class="line">PREFIX = <span class="string">'http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uploadToOSS</span><span class="params">(name, path)</span>:</span></span><br><span class="line">    accessKeyId = <span class="string">"YOUR ALIYUN ACCESSKEYID"</span></span><br><span class="line">    accessKeySecret = <span class="string">"YOUR ALIYUN ACCESSKEYSECRET"</span></span><br><span class="line">    <span class="comment"># endpoint = "oss-cn-qingdao-internal.aliyuncs.com"</span></span><br><span class="line">    endpoint = <span class="string">"oss-cn-hongkong.aliyuncs.com"</span></span><br><span class="line">    bucket = <span class="string">"peierlong-blog"</span></span><br><span class="line">    auth = oss2.Auth(accessKeyId, accessKeySecret)</span><br><span class="line">    service = oss2.Service(auth, endpoint)</span><br><span class="line">    bucketObj = oss2.Bucket(auth, endpoint, bucket)</span><br><span class="line">    bucketObj.put_object_from_file(name, path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getClipboardData</span><span class="params">()</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbpaste'</span>], stdout=subprocess.PIPE)</span><br><span class="line">    retcode = p.wait()</span><br><span class="line">    data = p.stdout.read()</span><br><span class="line">    <span class="comment"># 这里的data为bytes类型，之后需要转成utf-8操作</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setClipboardData</span><span class="params">(data)</span>:</span></span><br><span class="line">    p = subprocess.Popen([<span class="string">'pbcopy'</span>], stdin=subprocess.PIPE)</span><br><span class="line">    p.stdin.write(data)</span><br><span class="line">    p.stdin.close()</span><br><span class="line">    p.communicate()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"args error, ploease input the file path. "</span>)</span><br><span class="line"></span><br><span class="line">    path = sys.argv[<span class="number">1</span>]</span><br><span class="line">    obj_name = path[path.rfind(<span class="string">"/"</span>) + <span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'obj_name : '</span> + obj_name)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'start upload to oss ....'</span>)</span><br><span class="line">    uploadToOSS(obj_name, path)</span><br><span class="line">    print(<span class="string">'end upload to oss'</span>)</span><br><span class="line"></span><br><span class="line">    mk_img = <span class="string">'![%s](%s)'</span> % (obj_name, PREFIX + obj_name)</span><br><span class="line">    setClipboardData(bytes(mk_img, <span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'please CMD + v to paste markdown img grammar'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>The end!</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;oss2mk&quot;&gt;&lt;a href=&quot;#oss2mk&quot; class=&quot;headerlink&quot; title=&quot;oss2mk&quot;&gt;&lt;/a&gt;oss2mk&lt;/h1&gt;&lt;p&gt;由于&lt;code&gt;MWeb&lt;/code&gt;不支持阿里云图床，本脚本的主要功能时把图片上传到阿里云oss并把图片的markdown语法复制到粘贴板。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;GitHub地址: &lt;a href=&quot;https://github.com/peierlong/oss2mk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/peierlong/oss2mk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.peiel.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.peiel.com/tags/Python/"/>
    
      <category term="aliyun" scheme="http://blog.peiel.com/tags/aliyun/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器知识总结</title>
    <link href="http://blog.peiel.com/2018/03/09/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.peiel.com/2018/03/09/JVM垃圾收集器知识总结/</id>
    <published>2018-03-09T10:16:25.000Z</published>
    <updated>2019-03-13T02:32:01.036Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文大部分的知识来自于周志明大神的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）》</a>一书，系统学习JVM相关知识的强烈推荐。 </p></blockquote><h1 id="一、垃圾收集算法"><a href="#一、垃圾收集算法" class="headerlink" title="一、垃圾收集算法"></a>一、垃圾收集算法</h1><p>有关垃圾收集算法，有一个国外的大神用JS生成的动图直观的展示了垃圾回收的过程，有助于对垃圾收集算法的理解，这是文章<a href="https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/" target="_blank" rel="noopener">连接</a>。</p><h2 id="无垃圾回收-NO-GC"><a href="#无垃圾回收-NO-GC" class="headerlink" title="无垃圾回收(NO-GC)"></a>无垃圾回收(NO-GC)</h2><p>在程序运行结束后，一次性的对内存进行回收，是最简单的回收机制。其并发性能最高，如果能把任务的颗粒度变得更细，可以有效的清理垃圾。最大的缺点是对长时间运行的程序或者占用内存大的程序来说，非常容易内存溢出。</p><a id="more"></a><h2 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法(Reference Counting)"></a>引用计数算法(Reference Counting)</h2><p>每个对象都持有一个引用的计数器，每当有一个地方引用它时，计数器就加一，当引用失效时，计数器就减一，当计数器为零时，说明对象是可被回收的。引用计数器最大的缺陷时循环引用问题。而且在并发情况下，引用计数器存在线程安全问题。</p><h2 id="标记清除算法-Mark-Sweep"><a href="#标记清除算法-Mark-Sweep" class="headerlink" title="标记清除算法(Mark Sweep)"></a>标记清除算法(Mark Sweep)</h2><p>顾名思义，标记清除算法分为两个阶段，『标记』和『清除』。相对于引用计数算法，解决了循环引用的问题，并且开销要小，因为不需要维护计数器了。</p><p>标记清除算法会产生内存碎片，从而导致大对象无法获取到连续的内存空间。并且，两个阶段的执行效率都不高。</p><h2 id="标记整理算法-Mark-Compact"><a href="#标记整理算法-Mark-Compact" class="headerlink" title="标记整理算法(Mark Compact)"></a>标记整理算法(Mark Compact)</h2><p>标记整理算法是在标记清除算法的基础上进行改进的算法，标记过程和标记清除算法一下，标记后，会把所有对象向一端移动，然后清除其余内存。</p><h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法(Copying)"></a>复制算法(Copying)</h2><p>复制算法在针对对象存活率较低的场景下有较高的效率，复制算法会降低空间成本。在Java虚拟机堆内存新生代非常适合使用这种算法。</p><h1 id="Java垃圾收集器"><a href="#Java垃圾收集器" class="headerlink" title="Java垃圾收集器"></a>Java垃圾收集器</h1><p>Java垃圾收集器使用分代收集算法，由于垃圾收集主要集中在堆内存中，于是把堆分为”年轻代”和”年老代”，也把方法区在逻辑上称为”永久代”。年轻代中的对象存活时间较短，绝大部分垃圾收集器使用复制算法。年老代中对象存活时间较长，一般采用标记-清除或者标记-整理算法。下图为各个收集器是否</p><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/gc_collector.jpg" alt="gc_collector.jpg"></p><h2 id="年轻代中的垃圾收集器"><a href="#年轻代中的垃圾收集器" class="headerlink" title="年轻代中的垃圾收集器"></a>年轻代中的垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><ul><li>采用复制算法实现</li><li>单线程</li><li>GC线程执行时，必须 Stop The World</li></ul><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><ul><li>采用复制算法实现</li><li>多线程</li><li>多条GC线程并行执行，用户线程必须 Stop The World</li></ul><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><ul><li>采用复制算法实现</li><li>并行多线程收集器</li><li>多条GC线程并行执行，用户线程必须 Stop The World</li><li>其他收集器关注用户线程停顿时间，此收集器关注程序吞吐量。</li></ul><h2 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h2><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><ul><li>Serial Old收集器时Serial收集器的年老代版本</li><li>单线程收集器</li><li>标记-整理算法</li><li>是CMS算法的后备方案</li></ul><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><ul><li>Parallel Old是Parallel Scavenge收集器的老年代版本</li><li>多线程收集器</li><li>注重吞吐量以及CPU资源敏感场合，可以优先考虑Parallel Scavenge + Parallel Old的组合。</li></ul><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><ul><li>CMS(Concurrent Mark Sweep)收集器是一种以获取最短停顿时间目标的收集器。</li><li>使用标记清除算法实现</li><li>多线程</li></ul><p><strong>优点</strong>：</p><ul><li>并发收集</li><li>低停顿</li></ul><p><strong>缺点</strong>：</p><ul><li>CMS收集器对CPU资源非常敏感（回收线程数 (cpu数量 + 3)/4   所以CPU不足4个时，垃圾收集线程占用50% CPU资源 ）</li><li>CMS收集器无法处理浮动垃圾(Floating Garbage)</li><li>标记-清除算法带来的内存碎片处理</li></ul><p><strong>CMS过程：</strong></p><p><img src="http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/CMS-Process.jpg" alt="CMS-Process.jpg"></p><h1 id="remark"><a href="#remark" class="headerlink" title="remark"></a>remark</h1><p>由于G1收集器暂时使用并不主流，暂时不做过多的学习。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文大部分的知识来自于周志明大神的&lt;a href=&quot;https://book.douban.com/subject/24722612/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入理解Java虚拟机（第2版）》&lt;/a&gt;一书，系统学习JVM相关知识的强烈推荐。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;一、垃圾收集算法&quot;&gt;&lt;a href=&quot;#一、垃圾收集算法&quot; class=&quot;headerlink&quot; title=&quot;一、垃圾收集算法&quot;&gt;&lt;/a&gt;一、垃圾收集算法&lt;/h1&gt;&lt;p&gt;有关垃圾收集算法，有一个国外的大神用JS生成的动图直观的展示了垃圾回收的过程，有助于对垃圾收集算法的理解，这是文章&lt;a href=&quot;https://spin.atomicobject.com/2014/09/03/visualizing-garbage-collection-algorithms/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;连接&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;无垃圾回收-NO-GC&quot;&gt;&lt;a href=&quot;#无垃圾回收-NO-GC&quot; class=&quot;headerlink&quot; title=&quot;无垃圾回收(NO-GC)&quot;&gt;&lt;/a&gt;无垃圾回收(NO-GC)&lt;/h2&gt;&lt;p&gt;在程序运行结束后，一次性的对内存进行回收，是最简单的回收机制。其并发性能最高，如果能把任务的颗粒度变得更细，可以有效的清理垃圾。最大的缺点是对长时间运行的程序或者占用内存大的程序来说，非常容易内存溢出。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.peiel.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.peiel.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://blog.peiel.com/tags/JVM/"/>
    
  </entry>
  
</feed>
