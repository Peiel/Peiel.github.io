<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Docker命令汇总-上"><meta name="keywords" content="Docker"><meta name="author" content="Peiel"><meta name="copyright" content="Peiel"><title>Docker命令汇总-上 | Peiel's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?21ffc9c30ac4263d2d53f327c885f71d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-列出机器上的镜像（images）"><span class="toc-number">1.</span> <span class="toc-text">1. 列出机器上的镜像（images）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-在docker-index中搜索image（search）"><span class="toc-number">2.</span> <span class="toc-text">2. 在docker index中搜索image（search）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-从docker-registry-server-中下拉image或repository（pull）"><span class="toc-number">3.</span> <span class="toc-text">3. 从docker registry server 中下拉image或repository（pull）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-推送一个image或repository到registry（push）"><span class="toc-number">4.</span> <span class="toc-text">4. 推送一个image或repository到registry（push）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-从image启动一个container（run）"><span class="toc-number">5.</span> <span class="toc-text">5. 从image启动一个container（run）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-使用image创建container并执行相应命令，然后停止"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 使用image创建container并执行相应命令，然后停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用image创建container并进入交互模式-login-shell是-bin-bash"><span class="toc-number">5.2.</span> <span class="toc-text">使用image创建container并进入交互模式, login shell是/bin/bash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-运行出一个container放到后台运行"><span class="toc-number">5.3.</span> <span class="toc-text">5.2 运行出一个container放到后台运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-映射host到container的端口和目录"><span class="toc-number">5.4.</span> <span class="toc-text">5.3 映射host到container的端口和目录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-将一个container固化为一个新的image（commit）"><span class="toc-number">6.</span> <span class="toc-text">6. 将一个container固化为一个新的image（commit）</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Peiel</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/peierlong">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">76</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">50</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">21</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/home.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Peiel's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="post-info"><div id="post-title">Docker命令汇总-上</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-04-08</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Docker/">Docker</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文转载自：<a href="http://blog.csdn.net/permike/article/details/51879578" target="_blank" rel="noopener">http://blog.csdn.net/permike/article/details/51879578</a></p>
<p>根据自己的理解，总的来说分为以下几种：</p>
<ul>
<li>容器生命周期管理 — <code>docker [run|start|stop|restart|kill|rm|pause|unpause]</code></li>
<li>容器操作运维 — <code>docker [ps|inspect|top|attach|events|logs|wait|export|port]</code></li>
<li>容器rootfs命令 — <code>docker [commit|cp|diff]</code></li>
<li>镜像仓库 — <code>docker [login|pull|push|search]</code></li>
<li>本地镜像管理 — <code>docker [images|rmi|tag|build|history|save|import]</code></li>
<li>其他命令 — <code>docker [info|version]</code></li>
</ul>
<a id="more"></a>
<p><img src="https://segmentfault.com/img/bVdlRG" alt="https://segmentfault.com/img/bVdlRG"></p>
<h3 id="1-列出机器上的镜像（images）"><a href="#1-列出机器上的镜像（images）" class="headerlink" title="1. 列出机器上的镜像（images）"></a>1. 列出机器上的镜像（images）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker images </span><br><span class="line">REPOSITORY               TAG             IMAGE ID        CREATED         VIRTUAL SIZE</span><br><span class="line">ubuntu                   14.10           2185fd50e2ca    13 days ago     236.9 MB</span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<p>IMAGE ID列其实是缩写，要显示完整则带上<code>--no-trunc</code>选项</p>
<h3 id="2-在docker-index中搜索image（search）"><a href="#2-在docker-index中搜索image（search）" class="headerlink" title="2. 在docker index中搜索image（search）"></a>2. 在docker index中搜索image（search）</h3><p><code>Usage: docker search TERM</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker search seanlo</span><br><span class="line">NAME                DESCRIPTION           STARS     OFFICIAL   AUTOMATED</span><br><span class="line">seanloook/centos6   sean&apos;s docker repos         0</span><br></pre></td></tr></table></figure>
<p>搜索的范围是官方镜像和所有个人公共镜像。NAME列的 / 后面是仓库的名字。</p>
<h3 id="3-从docker-registry-server-中下拉image或repository（pull）"><a href="#3-从docker-registry-server-中下拉image或repository（pull）" class="headerlink" title="3. 从docker registry server 中下拉image或repository（pull）"></a>3. 从docker registry server 中下拉image或repository（pull）</h3><p><code>Usage: docker pull [OPTIONS] NAME[:TAG]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull centos</span><br></pre></td></tr></table></figure>
<p>上面的命令需要注意，在docker v1.2版本以前，会下载官方镜像的centos仓库里的所有镜像，而从v.13开始官方文档里的说明变了：will pull the centos:latest image, its intermediate layers and any aliases of the same id，也就是只会下载tag为latest的镜像（以及同一images id的其他tag）。<br>也可以明确指定具体的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull centos:centos6</span><br></pre></td></tr></table></figure>
<p>当然也可以从某个人的公共仓库（包括自己是私人仓库）拉取，形如</p>
<p><code>docker pull username/repository&lt;:tag_name&gt;</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull seanlook/centos:centos6</span><br></pre></td></tr></table></figure>
<p>如果你没有网络，或者从其他私服获取镜像，形如</p>
<p><code>docker pull registry.domain.com:5000/repos</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker pull dl.dockerpool.com:5000/mongo:latest</span><br></pre></td></tr></table></figure>
<h3 id="4-推送一个image或repository到registry（push）"><a href="#4-推送一个image或repository到registry（push）" class="headerlink" title="4. 推送一个image或repository到registry（push）"></a>4. 推送一个image或repository到registry（push）</h3><p>与上面的pull对应，可以推送到Docker Hub的Public、Private以及私服，但不能推送到Top Level Repository。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker push seanlook/mongo</span><br><span class="line"># docker push registry.tp-link.net:5000/mongo:2014-10-27</span><br></pre></td></tr></table></figure>
<p>registry.tp-link.net也可以写成172.29.88.222。<br>在repository不存在的情况下，命令行下push上去的会为我们创建为私有库，然而通过浏览器创建的默认为公共库。</p>
<h3 id="5-从image启动一个container（run）"><a href="#5-从image启动一个container（run）" class="headerlink" title="5. 从image启动一个container（run）"></a>5. 从image启动一个container（run）</h3><p><code>docker run</code>命令首先会从特定的image创之上create一层可写的<a href="http://lib.csdn.net/base/docker" target="_blank" rel="noopener">Container</a>，然后通过start命令来启动它。停止的container可以重新启动并保留原来的修改。run命令启动参数有很多，以下是一些常规使用说明，更多部分请参考<a href="http://www.cnphp6.com/archives/24899" target="_blank" rel="noopener">http://www.cnphp6.com/archives/24899</a><br>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<ul>
<li>检查本地是否存在指定的镜像，不存在就从公有仓库下载</li>
<li>利用镜像创建并启动一个容器</li>
<li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li>
<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li>
<li>从地址池配置一个 ip 地址给容器</li>
<li>执行用户指定的应用程序</li>
<li>执行完毕后容器被终止</li>
</ul>
<p><code>Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p>
<h4 id="5-1-使用image创建container并执行相应命令，然后停止"><a href="#5-1-使用image创建container并执行相应命令，然后停止" class="headerlink" title="5.1 使用image创建container并执行相应命令，然后停止"></a>5.1 使用image创建container并执行相应命令，然后停止</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run ubuntu echo &quot;hello world&quot;</span><br><span class="line">hello word</span><br></pre></td></tr></table></figure>
<p>这是最简单的方式，跟在本地直接执行<code>echo &#39;hello world&#39;</code> 几乎感觉不出任何区别，而实际上它会从本地ubuntu:latest镜像启动到一个容器，并执行打印命令后退出（<code>docker ps -l</code>可查看）。需要注意的是，默认有一个<code>--rm=true</code>参数，即完成操作后停止容器并从文件系统移除。因为Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。<br>容器启动后会自动随机生成一个<code>CONTAINER ID</code>，这个ID在后面commit命令后可以变为<code>IMAGE ID</code></p>
<h4 id="使用image创建container并进入交互模式-login-shell是-bin-bash"><a href="#使用image创建container并进入交互模式-login-shell是-bin-bash" class="headerlink" title="使用image创建container并进入交互模式, login shell是/bin/bash"></a>使用image创建container并进入交互模式, login shell是/bin/bash</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -i -t --name mytest centos:centos6 /bin/bash</span><br><span class="line">bash-4.1#</span><br></pre></td></tr></table></figure>
<p>上面的<code>--name</code>参数可以指定启动后的容器名字，如果不指定则docker会帮我们取一个名字。镜像<code>centos:centos6</code>也可以用<code>IMAGE ID</code> (68edf809afe7) 代替），并且会启动一个伪终端，但通过ps或top命令我们却只能看到一两个进程，因为容器的核心是所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外，并没有其它的资源，可见Docker对资源的利用率极高。</p>
<h4 id="5-2-运行出一个container放到后台运行"><a href="#5-2-运行出一个container放到后台运行" class="headerlink" title="5.2 运行出一个container放到后台运行"></a>5.2 运行出一个container放到后台运行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># docker run -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 2; done&quot;</span><br><span class="line">ae60c4b642058fefcc61ada85a610914bed9f5df0e2aa147100eab85cea785dc</span><br></pre></td></tr></table></figure>
<p>它将直接把启动的container挂起放在后台运行（这才叫saas），并且会输出一个<code>CONTAINER ID</code>，通过</p>
<p><code>docker ps</code>可以看到这个容器的信息，可在container外面查看它的输出<code>docker logs ae60c4b64205</code>，也可以通过<code>docker attach ae60c4b64205</code>连接到这个正在运行的终端，此时在<code>Ctrl+C</code>退出container就消失了，按ctrl-p ctrl-q可以退出到宿主机，而保持container仍然在运行<br>另外，如果-d启动但后面的命令执行完就结束了，如<code>/bin/bash</code>、<code>echo test</code>，则container做完该做的时候依然会终止。而且-d不能与–rm同时使用<br>可以通过这种方式来运行memcached、apache等。</p>
<h4 id="5-3-映射host到container的端口和目录"><a href="#5-3-映射host到container的端口和目录" class="headerlink" title="5.3 映射host到container的端口和目录"></a>5.3 映射host到container的端口和目录</h4><p>映射主机到容器的端口是很有用的，比如在container中运行memcached，端口为11211，运行容器的host可以连接container的 internel_ip:11211 访问，如果有从其他主机访问memcached需求那就可以通过-p选项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-p 11211:11211 这个即是默认情况下，绑定主机所有网卡（0.0.0.0）的11211端口到容器的11211端口上</span><br><span class="line">-p 127.0.0.1:11211:11211 只绑定localhost这个接口的11211端口</span><br><span class="line">-p 127.0.0.1::5000</span><br><span class="line">-p 127.0.0.1:80:8080</span><br></pre></td></tr></table></figure>
<p>目录映射其实是“绑定挂载”host的路径到container的目录，这对于内外传送文件比较方便，在搭建私服那一节，为了避免私服container停止以后保存的images不被删除，就要把提交的images保存到挂载的主机目录下。使用比较简单，<code>-v</code>，绑定多个目录时再加<code>-v</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v /tmp/docker:/tmp/docker</span><br></pre></td></tr></table></figure>
<p>另外在两个container之间建立联系可用<code>--link</code>，详见高级部分或<a href="http://docs.docker.com/v1.1/reference/commandline/cli/#run" target="_blank" rel="noopener">官方文档</a>。<br>下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># docker run --name nginx_test \</span><br><span class="line">&gt; -v /tmp/docker:/usr/share/nginx/html:ro \</span><br><span class="line">&gt; -p 80:80 -d \</span><br><span class="line">&gt; nginx:1.7.6</span><br></pre></td></tr></table></figure>
<p>在主机的/tmp/docker下建立index.html，就可以通过<code>http://localhost:80/</code>或<code>http://host-ip:80</code>访问了。</p>
<h3 id="6-将一个container固化为一个新的image（commit）"><a href="#6-将一个container固化为一个新的image（commit）" class="headerlink" title="6. 将一个container固化为一个新的image（commit）"></a>6. 将一个container固化为一个新的image（commit）</h3><p>当我们在制作自己的镜像的时候，会在container中安装一些工具、修改配置，如果不做commit保存起来，那么container停止以后再启动，这些更改就消失了。<br><code>docker commit  [repo:tag]</code><br>后面的repo:tag可选<br>只能提交正在运行的container，即通过<code>docker ps</code>可以看见的容器，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">查看刚运行过的容器</span><br><span class="line"># docker ps -l</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND      CREATED       STATUS        PORTS   NAMES</span><br><span class="line">c9fdf26326c9   nginx:1   nginx -g..   3 hours ago   Exited (0)..     nginx_test</span><br><span class="line"></span><br><span class="line">启动一个已存在的容器（run是从image新建容器后再启动），以下也可以使用docker start nginx_test代替  </span><br><span class="line">[root@hostname docker]# docker start c9fdf26326c9</span><br><span class="line">c9fdf26326c9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -i -t --sig-proxy=false 21ffe545748baf /bin/bash</span><br><span class="line">nginx服务没有启动</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># docker commit -m &quot;some tools installed&quot; fcbd0a5348ca seanlook/ubuntu:14.10_tutorial</span><br><span class="line">fe022762070b09866eaab47bc943ccb796e53f3f416abf3f2327481b446a9503</span><br></pre></td></tr></table></figure>
<p>请注意，当你反复去commit一个容器的时候，每次都会得到一个新的<code>IMAGE ID</code>，假如后面的<code>repository:tag</code>没有变，通过<code>docker images</code>可以看到，之前提交的那份镜像的<code>repository:tag</code>就会变成<code>:</code>，所以尽量避免反复提交。<br>另外，观察以下几点:</p>
<ul>
<li>commit container只会pause住容器，这是为了保证容器文件系统的一致性，但不会stop。如果你要对这个容器继续做其他修改：<ul>
<li>你可以重新提交得到新image2，删除次新的image1</li>
<li>也可以关闭容器用新image1启动，继续修改，提交image2后删除image1</li>
<li>当然这样会很痛苦，所以一般是采用<code>Dockerfile</code>来<code>build</code>得到最终image</li>
</ul>
</li>
<li>虽然产生了一个新的image，并且你可以看到大小有100MB，但从commit过程很快就可以知道实际上它并没有独立占用100MB的硬盘空间，而只是在旧镜像的基础上修改，它们共享大部分公共的“片”。</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Peiel</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.peierlong.com/2017/04/08/Docker命令汇总-上/">http://www.peierlong.com/2017/04/08/Docker命令汇总-上/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.peierlong.com">Peiel's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/04/08/Redis常用命令/"><i class="fa fa-chevron-left">  </i><span>Redis常用命令汇总</span></a></div><div class="next-post pull-right"><a href="/2017/03/27/Zookeeper序列化机制总结/"><span>Zookeeper序列化机制总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: 'f456aadd3f324c0f3d96',
  clientSecret: '236fe648338b51916e4a0527d2a083f50d1ba8d5',
  repo: 'peierlong.github.io',
  owner: 'peierlong',
  admin: 'peierlong',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(http://peierlong-blog.oss-cn-hongkong.aliyuncs.com/home.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Peiel</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="www.peierlong.com">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>